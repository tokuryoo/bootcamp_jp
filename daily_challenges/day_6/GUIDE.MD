# Daily guide : day 6 ğŸ‰

Welcome into the **day 6** of the Motoko Bootcamp ! <br/>
This is the last daily guide, if you've made it so far, congratulation. ğŸ¥³
Today we will cover the following topics : **Variant types**, **Result type**, **HTTP request** & **Intercanister messages**.

Motoko Bootcamp ã® **day 6** ã¸ã‚ˆã†ã“ã ! <br/>
ã“ã‚ŒãŒæœ€å¾Œã®ãƒ‡ã‚¤ãƒªãƒ¼ã‚¬ã‚¤ãƒ‰ã§ã™ã€ã“ã“ã¾ã§æ¥ã‚‰ã‚ŒãŸæ–¹ã€ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ã€‚ğŸ¥³
ä»Šæ—¥ã¯ä»¥ä¸‹ã®ãƒˆãƒ”ãƒƒã‚¯ã‚’ã‚«ãƒãƒ¼ã—ã¾ã™ã€‚**Variant types**, **Result type**, **HTTP request**, **Intercanister messages** ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚

You can access the official documentation for each topic.

å„ãƒˆãƒ”ãƒƒã‚¯ã®å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

- <a href="https://smartcontracts.org/docs/candid-guide/candid-types.html" target="_blank"> Variant </a>.
- <a href="https://smartcontracts.org/docs/language-guide/errors.html#_working_with_optionresult" target="_blank"> Result </a>.
- <a href="https://smartcontracts.org/docs/developers-guide/tutorials/intercanister-calls.html" target="_blank"> Intercanister calls </a>.

# Prerequisites å‰ææ¡ä»¶ âœ…

- Make sure you have dfx installed on your machine.
- ãŠä½¿ã„ã®ãƒã‚·ãƒ³ã«dfxãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚

  ```
  dfx --version
  ```

- Before reading this guide I recommend watching those two lectures.
- ã“ã®ã‚¬ã‚¤ãƒ‰ã‚’èª­ã‚€å‰ã«ã€ã“ã®2ã¤ã®è¬›ç¾©ã‚’è¦‹ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚


# Variant ğŸ„

A variant type represents one value that is from exactly **one** of the given cases, or <i> **tags** </i>.

variant å‹ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸã‚±ãƒ¼ã‚¹ã®ã†ã¡ã¡ã‚‡ã†ã© **1** ã®ã‚‚ã®ã€ã¤ã¾ã‚Š <i> **tags** </i> ã§ã‚ã‚‹ä¸€ã¤ã®å€¤ã‚’è¡¨ã—ã¾ã™ã€‚


```
type Vehicule = {
    #Car;
    #Moto;
    #Bicycle;
    #Plane;
    #Boat;
};

```

Each <i> **tag** </i> can have it's own type.

å„<i> **tag** </i>ã¯ã€ãã‚Œè‡ªèº«ã®å‹ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™ã€‚


```
import Time "mo:base/Time";
actor {
    type Time = Time.Time;
    type Health = {
        #invicible;
        #alive : Nat;
        #dead : Time;
    };
}
```

You will usually combine variants, with the switch/case expression we've seen before.

é€šå¸¸ã€å‰ã«è¦‹ãŸswitch/caseå¼ã§ã€ãƒãƒªã‚¢ãƒ³ãƒˆã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

```
import Time "mo:base/Time";
import Int "mo:base/Int";
import Nat "mo:base/Nat";
actor {

    type Time = Time.Time;
    public type Health = {
        #invicible;
        #alive : Nat;
        #dead : Time;
    };

    public func medical_check(h : Health) : async Text {
        switch(h){
            case(#invicible) {
                return("Woah I've never seen someone with s much energy !");
            };
            case(#alive(n)){
                return("You seem to be in good shape, you have " # Nat.toText(n) # " energy points");
            };
            case(#dead(t)){
                return("ğŸ’€ since " # Int.toText(t));
            };
        };
    };
}
```

You'll notice that one advantage of using variants, is that our switch/case doesn't need to cover the **(\_) case** !

variant ã‚’ä½¿ã†åˆ©ç‚¹ã¯ã€switch/case ãŒ **(\_) case** ã‚’ã‚«ãƒãƒ¼ã™ã‚‹å¿…è¦ãŒãªã„ã“ã¨ã§ã™!

# Challenge èª²é¡Œ ğŸ®

Take a break and try completing challenge 1 & 2.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸1ï¼†2ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ã¯ã„ã‹ãŒã§ã—ã‚‡ã†ã‹ã€‚

# Result type âœ… / ğŸš«

The type Result is extremly useful if you want to propagate errors and indicate to other people/developers what went wrong.

Resultå‹ã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’ä¼æ’­ã•ã›ã€ä½•ãŒå•é¡Œã ã£ãŸã®ã‹ã‚’ä»–ã®äººã‚„é–‹ç™ºè€…ã«ç¤ºã—ãŸã„å ´åˆã«éå¸¸ã«æœ‰åŠ¹ã§ã™ã€‚

The type **Result** is defined as :

å‹ **Result** ã¯ã€æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚


```
type Result<Ok, Err> = {#ok : Ok; #err : Err}
```

This means the type Result is just a variant with two tags #ok and #err. These two tags can be of type **Ok** and type **Err**.

ã¤ã¾ã‚Šã€Resultå‹ã¯2ã¤ã®ã‚¿ã‚°#okã¨#errã‚’æŒã¤å˜ãªã‚‹ãƒãƒªã‚¢ãƒ³ãƒˆã§ã‚ã‚‹ã€‚ã“ã‚Œã‚‰äºŒã¤ã®ã‚¿ã‚°ã¯ **Ok** å‹ã¨ **Err** å‹ã«ãªã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

One common type for **Ok** and **Err** is the following.

**Ok**ã¨**Err**ã®å…±é€šå‹ã¨ã—ã¦ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ãŒã‚ã‚‹ã€‚


```
type Result<(), Text> = {#ok ; #err : Text};
```

In case everything went right we just return #ok without additional informations, but if we encounter an error we want to propagate a message in the #err.

ã†ã¾ãã„ã£ãŸå ´åˆã¯è¿½åŠ æƒ…å ±ãªã—ã§#okã‚’è¿”ã™ã ã‘ã ãŒã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯#errã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¼ãˆãŸã„ã€‚

```
import Result "mo:base/Result";
import Principal "mo:base/Principal";
actor {
    public type Result = Result.Result;
    public shared ({caller}) func register() : async Result<(), Text> {
        if(Principal.isAnonymous(caller)){
            return #err("You need to be authenticated to register").
        } else {
            // Do something
            return #ok;
        }
    };
};

```

You could also create a variant type **Error** and use it in the Result.

ã¾ãŸã€ãƒãƒªã‚¢ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã® **Error** ã‚’ä½œæˆã—ã€Result ã§ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

# Challenge ğŸ®

Take a break and try completing challenge 3 to 5.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸3ï½5ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ãã ã•ã„ã€‚


# HTTP request

If you are not familiar with HTTP, I recommend watching this <a href="https://www.youtube.com/watch?v=iYM2zFP3Zn0" target="\_blank"> video </a> first.

HTTPã«æ…£ã‚Œã¦ã„ãªã„æ–¹ã¯ã€ã¾ãšã“ã¡ã‚‰ã®<a href="https://www.youtube.com/watch?v=iYM2zFP3Zn0" target="\_blank"> å‹•ç”»</a>ã‚’ã”è¦§ã«ãªã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

Canisters are able to answer http requests directly !

ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯httpã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ç›´æ¥ç­”ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ !

You need to implement an public method called http_request to allow you canister to answer any http call.

http_requestã¨ã„ã†ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¦ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒã‚ã‚‰ã‚†ã‚‹httpã‚³ãƒ¼ãƒ«ã«å¿œç­”ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

In a module called http.mo we will declare the following types.

http.mo ã¨ã„ã†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã€ä»¥ä¸‹ã®å‹ã‚’å®£è¨€ã—ã¾ã™ã€‚


```
module {
    public type HeaderField = (Text, Text);
    public type Request = {
        body    : Blob;
        headers : [HeaderField];
        method  : Text;
        url     : Text;
    };

    public type Response = {
        body               : Blob;
        headers            : [HeaderField];
        status_code        : Nat16;
        streaming_strategy : ?StreamingStrategy;
    };

      public type StreamingStrategy = {
        #Callback: {
            callback : StreamingCallback;
            token    : StreamingCallbackToken;
        };
    };

    public type StreamingCallback = query (StreamingCallbackToken) -> async (StreamingCallbackResponse);

    public type StreamingCallbackToken =  {
        content_encoding : Text;
        index            : Nat;
        key              : Text;
    };

    public type StreamingCallbackResponse = {
        body  : Blob;
        token : ?StreamingCallbackToken;
    };

};
```

In main.mo

```
import HTTP "http";
import Text "mo:base/Text";
actor {
  public query func http_request(request : HTTP.Request) : async HTTP.Response {
    let response = {
      body = Text.encodeUtf8("Hello world");
      headers = [("Content-Type", "text/html; charset=UTF-8")];
      status_code = 200 : Nat16;
      streaming_strategy = null
      };
      return(response)
    };
};
```

This is how we implement a basic http response for our canister !
Now if you deploy this canister and access it in your browser, you should see a blank page with the text !

ã“ã‚Œã¯ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ã«åŸºæœ¬çš„ãªhttpãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å®Ÿè£…ã™ã‚‹æ–¹æ³•ã§ã™!
ã“ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ã€ãƒ–ãƒ©ã‚¦ã‚¶ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ã€ç©ºç™½ã®ãƒšãƒ¼ã‚¸ã«ãƒ†ã‚­ã‚¹ãƒˆ!

# Challenge èª²é¡Œ ğŸ®

Take a break and try completing challenge 6 & 7.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸6ï¼†7ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

# Intercanister messages ğŸ’¬ (Bonus)

One of the best thing on the IC is the ability for a canister to call another canister methods just with a few lines of code. ğŸ¤¯

ICã§æœ€ã‚‚å„ªã‚Œã¦ã„ã‚‹ç‚¹ã¯ã€æ•°è¡Œã®ã‚³ãƒ¼ãƒ‰ã§ã€ã‚ã‚‹ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒåˆ¥ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã›ã‚‹ã“ã¨ã§ã™ã€‚ğŸ¤¯

The first thing you migth want to do is declare the interface of the actor you're gonna interact with.

æœ€åˆã«ã‚„ã‚‹ã¹ãã“ã¨ã¯ã€å¯¾è©±ã™ã‚‹ã‚¢ã‚¯ã‚¿ãƒ¼ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’å®£è¨€ã™ã‚‹ã“ã¨ã§ã™ã€‚

Let's imagine we have an actor defined somewhere else.

ã©ã“ã‹åˆ¥ã®å ´æ‰€ã§å®šç¾©ã•ã‚ŒãŸã‚¢ã‚¯ã‚¿ãƒ¼ã‚’æƒ³åƒã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```
actor Stranger {

  public shared ({caller}) func hello() : async Text {
      return("I was called by )
  }

  public shared ({caller}) func another_function_that_does_something() : async () {
      //Do something
      return;
  };
}
```

We would define it's interface like this. <br/> (If the actor have severals methods but you only want to call one you don't need to declare all other methods).

ã“ã®ã‚ˆã†ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’å®šç¾©ã—ã¾ã™ã€‚<br/> (ã‚¢ã‚¯ã‚¿ãƒ¼ãŒè¤‡æ•°ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã¦ã€1ã¤ã ã‘å‘¼ã³å‡ºã—ãŸã„å ´åˆã€ä»–ã®ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®£è¨€ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚


```
let other_canister : actor {
    hello : () -> async Text;
} = actor("CANISTER_ID");
```

You'll notice that you need to specify the canister id of the canister you're trying to call. <br/>
Then, in our **own** actor we would call if that way.

å‘¼ã³å‡ºãã†ã¨ã™ã‚‹ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼IDã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã«æ°—ãŒã¤ãã§ã—ã‚‡ã†ã€‚<br/>
ãã—ã¦ã€ç§ãŸã¡ã® **own** ã‚¢ã‚¯ã‚¿ã§ã€ãã®ã‚ˆã†ã«å‘¼ã³å‡ºã™ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

```
actor {

    let other_canister : actor { hello : () -> async Text} = actor("CANISTER_ID");
    public func test() : async Text {
        return(await other_canister.hello())
    };
}
```

You'll also notice that we need to **await** calls to the other canister.

ã¾ãŸã€ã‚‚ã†ä¸€ã¤ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¸ã®å‘¼ã³å‡ºã—ã‚’ **await** ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã«ã‚‚ãŠæ°—ã¥ãã§ã—ã‚‡ã†ã€‚

# Challenge èª²é¡Œ ğŸ®

Take your last break (ğŸ¥³) and try completing challenge 7 to 10.

æœ€å¾Œã®ä¼‘æ†©ï¼ˆğŸ¥³ï¼‰ã‚’ã—ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸7ï½10ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ãã ã•ã„ã€‚
