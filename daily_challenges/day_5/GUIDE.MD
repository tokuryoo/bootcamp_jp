# Daily guide : day 5 ğŸ¦†

Welcome into the **day 5** of the Motoko Bootcamp ! <br/>
Motoko Bootcamp ã® **day 5** ã¸ã‚ˆã†ã“ã!<br/>

Today we will cover the following topics : **Principal**, **Hashmap**, **Cycles** (how to deal with upgrades) & **stable variables**.

æœ¬æ—¥ã¯ã€ä»¥ä¸‹ã®ãƒˆãƒ”ãƒƒã‚¯ã‚’å–ã‚Šä¸Šã’ã¾ã™ã€‚: **Principal**, **Hashmap**, **Cycles**ï¼ˆã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®å¯¾å‡¦æ³•ï¼‰ã¨ **stable** ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚

You can access the official documentation for each topic.

å„ãƒˆãƒ”ãƒƒã‚¯ã®å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

- <a href="https://smartcontracts.org/docs/language-guide/caller-id.html" target="_blank"> Principal </a>.
- <a href="https://smartcontracts.org/docs/base-libraries/HashMap.html" target="_blank"> Hashmap </a>.
- <a href="https://smartcontracts.org/docs/language-guide/upgrades.html" target="_blank"> Stable variables & upgrade </a>.
- <a href="https://smartcontracts.org/docs/developers-guide/concepts/tokens-cycles.html" target="_blank"> Cycles </a>.

# Prerequisites å‰ææ¡ä»¶ âœ…

- Make sure you have dfx installed on your machine.
- ãŠä½¿ã„ã®ãƒã‚·ãƒ³ã«dfxãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚

  ```
  dfx --version
  ```

- Before reading this guide I recommend watching those two lectures.
- ã“ã®ã‚¬ã‚¤ãƒ‰ã‚’èª­ã‚€å‰ã«ã€ã“ã®2ã¤ã®è¬›ç¾©ã‚’è¦‹ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

  - Create, Read, Upgrade & Delete & Hashmap. (entire lecture)
  - ä½œæˆã€èª­ã¿è¾¼ã¿ã€ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã€å‰Šé™¤ã€ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ï¼ˆå…¨è¬›ç¾©ï¼‰ã€‚
  - Cycle managament (TODO : ADD TIME)
  - ã‚µã‚¤ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆï¼ˆTODO : æ™‚é–“ã‚’è¿½åŠ ï¼‰

# Principal ğŸ†”

The notion of **Principal** is specific to the Internet Computer. <br/> A principal is a unique identifier fo all entities on the IC

**Principal** ã¨ã„ã†æ¦‚å¿µã¯ã€Internet Computer ã«ç‰¹æœ‰ã®ã‚‚ã®ã§ã‚ã‚‹ã€‚<br/>
Principal ã¨ã¯ã€IC ä¸Šã®ã™ã¹ã¦ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ä¸€æ„ã«è­˜åˆ¥ã™ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚


- A canister has it's own principal (which corresponds to the canister id)
- Each user has it's own principal.
- Your wallet has it's own principal.
- ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ã¯ç‹¬è‡ªã®ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã‚’æŒã¡ã¾ã™ (ã“ã‚Œã¯ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ ID ã«å¯¾å¿œã—ã¾ã™)ã€‚
- å„ãƒ¦ãƒ¼ã‚¶ã¯ç‹¬è‡ªã®ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã‚’æŒã¡ã¾ã™ã€‚
- ã‚ãªãŸã®è²¡å¸ƒã¯ç‹¬è‡ªã®ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

You can access the principal of your dfx identity running the following command.

ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã€dfx IDã®ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```
dfx identity get-principal
ubetf-42t5l-l64h6-ljrqr-6ztbu-tanvs-jrwiv-a45x4-ucoxp-cqr4i-mqe //My dfx principal
```

<p align="center"> <img src="img/plug.png" width="400"/> </p>

Here we also have a principal.
ã“ã“ã§ã¯ã€ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã‚‚ã‚ã‚Šã¾ã™ã€‚

Each message on the IC contains the information about the principal of the caller.
You can access this information in Motoko with the following syntax.

ICä¸Šã®å„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯ã€ç™ºå‘¼å´ã®ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã«é–¢ã™ã‚‹æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
Motokoã§ã¯ã€ä»¥ä¸‹ã®æ§‹æ–‡ã§ã“ã®æƒ…å ±ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```
public shared(msg) func whoami() : async Principal {
    let principal_caller = msg.caller;
    return(principal_caller);
};
```

The principal is accessible using msg.caller.
You can also use this syntax.

ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã¯ msg.caller ã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
ã¾ãŸã€ã“ã®æ§‹æ–‡ã‚‚ä½¿ç”¨ã§ãã¾ã™ã€‚

```
public shared({caller}) func whoami() : async Principal {
    return(caller);
};
```

On the Internet Computer there is a special principal, it's called the **Anonymous** principal.
The textual version of this principal is **2vxsx-fae**. It corresponds to any user that is not authenticated.

Internet Computer ã«ã¯ç‰¹åˆ¥ãªãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ãŒã‚ã‚Šã€ãã‚Œã¯ **Anonymous** ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚
ã“ã®ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã®ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€**2vxsx-fae** ã§ã™ã€‚ã“ã‚Œã¯ã€èªè¨¼ã•ã‚Œã¦ã„ãªã„ã™ã¹ã¦ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å¯¾å¿œã—ã¾ã™ã€‚

Finally, in Motoko there is a <a href="https://smartcontracts.org/docs/base-libraries/Principal.html" target="_blank"> **Principal** </a> module for basic operations on principals.

æœ€å¾Œã«ã€Motoko ã«ã¯ã€ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã«å¯¾ã™ã‚‹åŸºæœ¬çš„ãªæ“ä½œã‚’è¡Œã†ãŸã‚ã® <a href="https://smartcontracts.org/docs/base-libraries/Principal.html" target="_blank"> **Principal** </a> ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚

# Challenge ğŸ®

Take a break and try completing challenge 1.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸1ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ã¯ã„ã‹ãŒã§ã—ã‚‡ã†ã‹ã€‚

# HashMap ğŸ—

An HashMap is a **key** / **value** store that allow you to store elements of type **value** and later retrieve them using an element of type **key**.
Usually, we note the type of the keys : **K** & the type of the values : **V**.

HashMap ã¯ã€**key** / **value** å‹ã®ã‚¹ãƒˆã‚¢ã§ã€**value** å‹ã®è¦ç´ ã‚’ä¿å­˜ã—ã€å¾Œã§ **key** å‹ã®è¦ç´ ã‚’ä½¿ç”¨ã—ã¦ãã‚Œã‚‰ã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚
é€šå¸¸ã€ã‚­ãƒ¼ã®å‹ã¯**K**ã¨è¡¨è¨˜ã—ã¾ã™ã€‚å€¤ã®å‹ã¯ **V** ã¨è¡¨è¨˜ã—ã¾ã™ã€‚

You can create an HashMap and use it by importing the **HashMap** module (don't forget the capital M). <br/>
This is how you would instantiate your first HashMap, with **Keys** of type **Principal** and value of type **Name**.

HashMap ã‚’ä½œæˆã—ã€ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€**HashMap** ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ï¼ˆå¤§æ–‡å­—ã®Mã‚’å¿˜ã‚Œãªã„ã§ãã ã•ã„ï¼‰ã€‚
ã“ã‚Œã¯ã€æœ€åˆã®HashMapã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹æ–¹æ³•ã§ã€**Keys** ã¯ **Principal** å‹ã§ã€valueã¯ **Name** å‹ã§ã‚ã‚‹ã€‚

```
import HashMap "mo:base/HashMap";
import Principal "mo:base/Principal";
actor {

    let anonymous_principal : Principal = Principal.fromText("2vxsx-fae");
    let users = HashMap.HashMap<Principal, Text>(0, Principal.equal, Principal.hash);
    users.put(anonymous_principal, "This is the anonymous principal");

    public func test() : async ?Text {
        return(users.get(Principal.fromText("2vxsx-fae")));
    };


};
```

There is a lot going on. At this point you're probably not surprised by the Motoko syntax : HashMap.HashMap, it simply means that we import the HashMap object from the HashMap module. <br/>

ã„ã‚ã„ã‚ã‚ã‚‹ã®ã§ã™ã€‚ã“ã®æ™‚ç‚¹ã§ã€Motoko æ§‹æ–‡ : HashMap.HashMap ã«ã¯é©šã‹ãªã„ã§ã—ã‚‡ã†ã€‚ã“ã‚Œã¯ã€å˜ã« HashMap ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ HashMap ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚<br/>

Then we have three arguments to instantiate the HashMap.

ãã—ã¦ã€HashMapã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ãŸã‚ã®3ã¤ã®å¼•æ•°ã‚’ç”¨æ„ã—ã¾ã™ã€‚

- 0 corresponds to the initial capacity of the HashMap. The capacity will automatically grow for you everytime you reach the maximum capacity of the HashMap, you don't need to worry about it ğŸ¥³.

- 0ã¯ã€HashMapã®åˆæœŸå®¹é‡ã«ç›¸å½“ã—ã¾ã™ã€‚HashMapã®æœ€å¤§å®¹é‡ã«é”ã™ã‚‹ãŸã³ã«ã€è‡ªå‹•çš„ã«å®¹é‡ãŒå¤§ãããªã‚‹ã®ã§ã€å¿ƒé…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ ğŸ¥³ã€‚

- Principal.equal is needed to compare the Keys.

- Keyã®æ¯”è¼ƒã«ã¯ã€Principal.equalãŒå¿…è¦ã§ã™ã€‚

- Principal.hash is needed to hash the Keys.

- Principal.hashã¯Keyã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã™ã‚‹ãŸã‚ã«å¿…è¦ã§ã™ã€‚

If you are not familiar with the concept of **hash** and **hash table**, I recommend watching this <a href="https://www.youtube.com/watch?v=KyUTuwz_b7Q" target="_blank"> video </a>.

ã‚‚ã—ã€**ãƒãƒƒã‚·ãƒ¥**ã¨**ãƒãƒƒã‚·ãƒ¥ãƒ†ãƒ¼ãƒ–ãƒ«**ã®æ¦‚å¿µã«é¦´æŸ“ã¿ãŒãªã‘ã‚Œã°ã€ã“ã®<a href="https://www.youtube.com/watch?v=KyUTuwz_b7Q" target="_blank"> ãƒ“ãƒ‡ã‚ª</a>ã‚’è¦‹ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

I really encourage you to understand the inner working of the HashMap, that way you'll get why we need to provide Principal.equal & Principal.hash.

HashMapã®å†…éƒ¨æ§‹é€ ã‚’ç†è§£ã™ã‚‹ã“ã¨ã§ã€ãªãœPrincipal.equalã¨Principal.hashã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã‹ã‚’ç†è§£ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚


Let's move to the pratical application.
You can add values inside the HashMap using the following syntax.

ã§ã¯ã€å®Ÿéš›ã«å¿œç”¨ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
HashMapã®å†…éƒ¨ã«å€¤ã‚’è¿½åŠ ã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```
import HashMap "mo:base/HashMap";
import Principal "mo:base/Principal";
actor {

    let anonymous_principal : Principal = Principal.fromText("2vxsx-fae");
    let users = HashMap.HashMap<Principal, Text>(0, Principal.equal, Principal.hash);
    users.put(anonymous_principal, "This is the anonymous principal");

    public func test() : async ?Text {
        return(users.get(Principal.fromText("2vxsx-fae")));
    };

};
```

Here I have added the value **"This is the anonymous principal"** with the **Key** that corresponds to the anonymous principal.
ã“ã“ã§ã¯ã€å€¤ **"This is the anonymous principal "** ã¨åŒ¿åãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã«å¯¾å¿œã™ã‚‹ **Key** ã‚’è¿½åŠ ã—ã¦ã„ã¾ã™ã€‚

Let's try to retrieve our value.

å€¤ã‚’å–å¾—ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```
import HashMap "mo:base/HashMap";
import Principal "mo:base/Principal";
actor {

    let anonymous_principal : Principal = Principal.fromText("2vxsx-fae");
    let users = HashMap.HashMap<Principal, Text>(0, Principal.equal, Principal.hash);
    users.put(anonymous_principal, "This is the anonymous principal");

    public func test() : async ?Text {
        return(users.get(Principal.fromText("2vxsx-fae")));
    };


};
```

Deploying this actor in the Motoko playground and running the test will return :

ã“ã®ã‚¢ã‚¯ã‚¿ã‚’ Motoko ãƒ—ãƒ¬ã‚¤ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«é…ç½®ã—ã¦ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€:

```
(opt "This is the anonymous principal")
```

# Challenge èª²é¡Œ ğŸ®

Take a break and try completing challenge 2 to 5.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸2ï½5ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

# Cycles ğŸ’°

Every canister on the Internet Computer consumes **cycles**. Those are used to
measure and pay for **computation** and **storage**. <br/>

Internet Computer ã®ã™ã¹ã¦ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ã€**Cycle** ã‚’æ¶ˆè²»ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯
**ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°** ã¨ **ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸** ã‚’æ¸¬å®šã—ã€æ–™é‡‘ã‚’æ”¯æ‰•ã†ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚<br/>

This is a table summing up the cost of each common operation in cycles.

ã“ã‚Œã¯ã€ä¸€èˆ¬çš„ãªå„æ“ä½œã®ã‚³ã‚¹ãƒˆã‚’ã‚µã‚¤ã‚¯ãƒ«ã§ã¾ã¨ã‚ãŸè¡¨ã§ã™ã€‚

<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Cycles Cost per Transaction (as of July 26, 2021)</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Transaction</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-right valign-top">All Application Subnets</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Canister Created</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For creating canisters on a subnet</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">100,000,000,000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compute Percent Allocated Per Second</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For each percent of the reserved compute allocation (a scarce resource).</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">100,000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Update Message Execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For every update message executed</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">590,000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ten Update Instructions Execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For every 10 instructions executed when executing update type messages</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Xnet Call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For every inter-canister call performed (includes the cost for sending the request and receiving the response)</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">260,000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Xnet Byte Transmission</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For every byte sent in an inter-canister call (for bytes sent in the request and response)</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1,000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ingress Message Reception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For every ingress message received</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1,200,000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ingress Byte Reception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For every byte received in an ingress message</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">2,000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GB Storage Per Second</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For storing a GB of data per second</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">127,000</p></td>
</tr>
</tbody>
</table>

Each canister has it's own cycle balance and can transfer cycles to other canisters through messages. <br/>
In Motoko, you can use the <a href="https://smartcontracts.org/docs/base-libraries/ExperimentalCycles.html" target="_blank"> ExperimentalCycles </a> module to play and experiment with cycles. (This module is likely to be modified in the future).

å„ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ç‹¬è‡ªã®ã‚µã‚¤ã‚¯ãƒ«ãƒãƒ©ãƒ³ã‚¹ã‚’æŒã¡ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã‚ˆã£ã¦ä»–ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«ã‚µã‚¤ã‚¯ãƒ«ã‚’è»¢é€ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚<br/>
Motoko ã§ã¯ã€<a href="https://smartcontracts.org/docs/base-libraries/ExperimentalCycles.html" target="_blank"> ExperimentalCycles </a> ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ã€ã‚µã‚¤ã‚¯ãƒ«ã§éŠã‚“ã ã‚Šå®Ÿé¨“ã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚(ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å°†æ¥çš„ã«ä¿®æ­£ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼‰ã€‚

This is how you can access the balance of a canister.

ã“ã®ã‚ˆã†ã«ã—ã¦ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®æ®‹é«˜ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ã€‚

```
import Cycles "mo:base/ExperimentalCycles";
actor {

    public func balance() : async Nat {
        return(Cycles.balance())
    };
};
```

Each message sent on the IC contains a number of cycles attached to it.
You can look the available amount with the following code.

ICã§é€ä¿¡ã•ã‚Œã‚‹å„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯ã€ã‚µã‚¤ã‚¯ãƒ«æ•°ãŒä»˜åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚
æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã§ä½¿ç”¨å¯èƒ½ãªé‡ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```
import Cycles "mo:base/ExperimentalCycles";
actor {

    public func message_available() : async Nat {
        return(Cycles.available())
    };
};
```

If you want to make your users pay in cycles to access a functionality, you can do so.

ã‚ã‚‹æ©Ÿèƒ½ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚µã‚¤ã‚¯ãƒ«æ‰•ã„ã‚’ã•ã›ãŸã„å ´åˆã€ãã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```
import Cycles "mo:base/ExperimentalCycles";
actor {

    let AMOUNT_TO_PAY : Nat = 100_000;
    public func pay_to_access() : async Text {
        if(Cycles.available() < 100_000) {
            return("This is not enough, send more cycles.");
        }:
        let received = Cycles.accept(AMOUNT_TO_PAY);
        return("Thanks for paying, you are now a premium user ğŸ˜");
    };
};
```

# Challenge èª²é¡Œ

Take a break and try completing challenge 6 & 7.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸6ï¼†7ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

# Stable variables // Stableå¤‰æ•°âœï¸

By default, when you upgrade a canister you'll will loose all state. ğŸ˜¢ <br/>
Let's say we have a variable called **counter** that been previously incremented; the value of this variable will be reset after an upgrade.
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‚’ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã™ã‚‹ã¨ã€ã™ã¹ã¦ã®ã‚¹ãƒ†ãƒ¼ãƒˆãŒå¤±ã‚ã‚Œã¾ã™ã€‚ğŸ˜¢<br/>
ä¾‹ãˆã°ã€**counter**ã¨ã„ã†å¤‰æ•°ãŒã‚ã‚Šã€ä»¥å‰ã¯ã“ã®å¤‰æ•°ãŒã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã¦ã„ãŸã¨ã—ã¾ã™ã€‚ã“ã®å¤‰æ•°ã®å€¤ã¯ã€ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰å¾Œã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚

```
actor {

    var my_name : Text = "";

    public func change_name(name : Text) : async () {
        ny_name := name;
    };

    public func show_name() : async Text {
        return(my_name)
    };

};
```

Here's what you can experiment with this actor (after deployment on the Motoko playground)

ã“ã®ã‚¢ã‚¯ã‚¿ãƒ¼ã‚’ä½¿ã£ãŸå®Ÿé¨“ã‚’ç´¹ä»‹ã—ã¾ã™ï¼ˆMotokoã®ãƒ—ãƒ¬ã‚¤ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«å±•é–‹å¾Œï¼‰ã€‚

```
change_name("Motoko");
show_name()  // "Motoko"
```

Now let's try to add something and redeploy our canister, we are trying to run an upgrade.

```
actor {

    var new_value : Text = "Let's upgrade";
    var my_name : Text = "";

    public func change_name(name : Text) : async () {
        my_name := name;
    };

    public func show_name() : async Text {
        return(my_name)
    };


};
```

```
show_name() // ""
```

Looks like the canister has forgotten his name..
Fortunately there is a way to keep state accross upgrades in Motoko. <br/> You can do so with **stable variable** !

ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯è‡ªåˆ†ã®åå‰ã‚’å¿˜ã‚ŒãŸã‚ˆã†ã ã€‚ å¹¸ã„ãªã“ã¨ã«ã€Motokoã§ã¯ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ãŸã³ã«çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚<br/>
**stable å¤‰æ•°** ã‚’ä½¿ãˆã°å¯èƒ½ã§ã™ã€‚

```
actor {

    stable var my_name : Text = "";

    public func change_name(name : Text) : async () {
        my_name := name;
    };

    public func show_name() : async Text {
        return(my_name)
    };

};
```

If you try the same suite of operations with this actor, you'll notice that the value of the counter is kept accross the upgrade.

ã“ã®ã‚¢ã‚¯ã‚¿ãƒ¼ã§åŒã˜æ“ä½œã‚’è©¦ã™ã¨ã€ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã®å€¤ãŒã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®é–“ã€ä¿æŒã•ã‚Œã¦ã„ã‚‹ã“ã¨ã«æ°—ã¥ãã§ã—ã‚‡ã†ã€‚

Unfortunately only some variables/objects can be defined as stable. <br/> An HashMap for instance, cannot be defined as stable. <br/>

æ®‹å¿µãªãŒã‚‰ï¼Œå®‰å®šã¨å®šç¾©ã§ãã‚‹ã®ã¯ä¸€éƒ¨ã®å¤‰æ•°/ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã ã‘ã§ã™ï¼<br/>
ä¾‹ãˆã°ã€HashMap ã¯å®‰å®šã¨å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚

In those cases, you need to use the following systems hooks.

ãã®ã‚ˆã†ãªå ´åˆã¯ã€ä»¥ä¸‹ã®ã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒƒã‚¯ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚


```
 system func preupgrade() {
    // Do something before upgrade
  };

  system func postupgrade() {
    // Do something after upgrade
  };
}
```

The trick is to use the **preupgrade** method to put all data into stable variables, and use to stable variables to reinitialize your canister state.

ã‚³ãƒ„ã¯ã€**preupgrade** ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å®šå¤‰æ•°ã«å…¥ã‚Œã€å®‰å®šå¤‰æ•°ã‚’ä½¿ç”¨ã—ã¦ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®çŠ¶æ…‹ã‚’å†åˆæœŸåŒ–ã™ã‚‹ã“ã¨ã§ã™ã€‚

(For more informations : https://smartcontracts.org/docs/language-guide/upgrades.html)

(è©³ç´°ã¯ã“ã¡ã‚‰ : https://smartcontracts.org/docs/language-guide/upgrades.html)

# Challenge èª²é¡Œ ğŸ®

Take a break and try completing challenge 8 to 10.

ä¸€æ¯ã¤ã„ã¦ã‹ã‚‰ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸8ï½10ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ãã ã•ã„ã€‚
