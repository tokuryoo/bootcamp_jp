# Daily guide : day 2 ğŸ£

Welcome into the **day 2** of the Motoko Bootcamp ! <br/>
Today we will cover the following topics : **Binary**, **Nat 8**, **Char** and **Text**.

Motoko Bootcamp ã® **day 2** ã¸ã‚ˆã†ã“ã! <br/>
æœ¬æ—¥ã¯ã€ä»¥ä¸‹ã®ãƒˆãƒ”ãƒƒã‚¯ã‚’å–ã‚Šä¸Šã’ã¾ã™ : **Binary**, **Nat 8**, **Char** and **Text**. 

# Prerequisites å‰ææ¡ä»¶âœ…

- Before taking on this lesson I **strongly** recommend watching this introduction to Computer Science from Harvard : https://www.youtube.com/watch?v=1tnj3UCkuxU
  <br/> <br/> You should start the video from the beggining and watch until **35:40** (I recommend watching the whole video if you can but the most important topics related to this lesson are covered in the first part of the video).
- ã“ã®ãƒ¬ãƒƒã‚¹ãƒ³ã«å‚åŠ ã™ã‚‹å‰ã«ã€ãƒãƒ¼ãƒãƒ¼ãƒ‰å¤§å­¦ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã‚µã‚¤ã‚¨ãƒ³ã‚¹ã®ç´¹ä»‹ã‚’è¦‹ã‚‹ã“ã¨ã‚’ **å¼·ã** ãŠå‹§ã‚ã—ã¾ã™ : https://www.youtube.com/watch?v=1tnj3UCkuxU
  <br/> <br/>ãƒ“ãƒ‡ã‚ªã¯æœ€åˆã‹ã‚‰å§‹ã‚ã¦ã€**35:40**ã¾ã§è¦‹ã¦ãã ã•ã„ï¼ˆã§ãã‚Œã°å…¨éƒ¨è¦‹ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ãŒã€ã“ã®ãƒ¬ãƒƒã‚¹ãƒ³ã«é–¢é€£ã™ã‚‹æœ€ã‚‚é‡è¦ãªãƒˆãƒ”ãƒƒã‚¯ã¯ã€ãƒ“ãƒ‡ã‚ªã®æœ€åˆã®éƒ¨åˆ†ã§ã‚«ãƒãƒ¼ã•ã‚Œã¦ã„ã¾ã™ï¼‰ã€‚

- Make sure have dfx installed on your machine.
- ãŠä½¿ã„ã®ãƒã‚·ãƒ³ã«dfxãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚

  ```
  dfx --version
  ```

- Start a new project called **day_2** and turn on your local replica.
- æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ **day_2** ã‚’é–‹å§‹ã—ã€ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒ¬ãƒ—ãƒªã‚«ã‚’ã‚ªãƒ³ã«ã—ã¾ã™ã€‚

  ```
  dfx new day_2
  cd day_2
  dfx start
  ```

# Decimal ğŸ”¢

Decimal is a base-10 **number system**, which uses ten digits (0 to 9), this is the primarly systems used by humans (probably because we have 10 fingers to count).

10 é€²æ³•ã¯ã€10 æ¡ï¼ˆ0ã€œ9ï¼‰ã®æ•°å­—ã‚’ä½¿ã†åŸºæœ¬ 10 é€²æ³•ã§ã€äººé–“ãŒä¸»ã«ä½¿ã†æ•°å­—ã§ã™ï¼ˆäººé–“ã«ã¯æ•°ãˆã‚‹ãŸã‚ã®æŒ‡ãŒ10æœ¬ã‚ã‚‹ã‹ã‚‰ã§ã—ã‚‡ã†ï¼‰ã€‚

<p align="center"> <img src="img/decimal_system.jpeg" width="400"/> </p>

In the decimal system, once you've reached the last digit (which is 9), you add a new digits and restart counting from 0 at the right-most digit.

10é€²æ³•ã§ã¯ã€æœ€å¾Œã®æ¡ï¼ˆ9ï¼‰ã«åˆ°é”ã—ãŸã‚‰ã€æ–°ã—ã„æ¡ã‚’è¿½åŠ ã—ã¦ã€ä¸€ç•ªå³ã®æ¡ã®0ã‹ã‚‰æ•°ãˆç›´ã—ã¾ã™ã€‚

    0 1 2 3 4 5 6 7 8 9 ... wait I don't have any digits anymore ? ğŸ˜§

    10 11 12 .... 99 wait I don't have any digits anymore ?  ğŸ˜§

    0 1 2 3 4 5 6 7 8 9 ...å¾…ã¦ã‚ˆã€ã‚‚ã†æ¡ãŒãªã„ã‚“ã ã‘ã©ï¼ŸğŸ˜§

    10 11 12 .... 99 å¾…ã£ã¦......ã‚‚ã†1æ¡ã‚‚ãªã„ã‚“ã ã‘ã©ï¼Ÿ ğŸ˜§

Each digit represents a **power** of 10.
å„æ¡ã¯10ã®**ä¹—**ã‚’è¡¨ã—ã¾ã™ã€‚

1234 = 1 x 1000 + 2 x 100 + 3 x 10 + 4 x 1 = 1 x 10 <sup>3</sup> + 2 x 10 <sup>2</sup> + 3 x 10 <sup>1</sup>+ 4 x 10 <sup>0</sup>.

# Binary ğŸŸ¢ ğŸ”´

Binary is a base-2 **number system**, it only uses two digits (0 and 1). <br/> This is the system used at the heart of all computers : every number, every character, every image, every video is encoded as binary for a computer.

2é€²æ³•ã¯ã€2æ¡ã®æ•°å­—ï¼ˆ0ã¨1ï¼‰ã ã‘ã‚’ä½¿ç”¨ã™ã‚‹åŸºæœ¬2é€²æ³•ã§ã™ã€‚<br/>ã™ã¹ã¦ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®å¿ƒè‡“éƒ¨ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚ã™ã¹ã¦ã®æ•°å­—ã€æ–‡å­—ã€ç”»åƒã€å‹•ç”»ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ãŸã‚ã«2é€²æ•°ã¨ã—ã¦ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã¾ã™ã€‚

ğŸ’¡ Using two digits is not a random choice. <br/> Computers are built using **transistors** which are tiny little door that can be closed or open to let electricity flow. âš¡ï¸

ğŸ’¡ 2æ¡ã®æ•°å­—ã‚’ä½¿ã†ã®ã¯ã€ç„¡ä½œç‚ºã®é¸æŠã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚<br/>ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã¯ã€**ãƒˆãƒ©ãƒ³ã‚¸ã‚¹ã‚¿**ã¨ã„ã†ã€é›»æ°—ã‚’æµã™ãŸã‚ã«é–‰ã˜ãŸã‚Šé–‹ã„ãŸã‚Šã§ãã‚‹å°ã•ãªå°ã•ãªãƒ‰ã‚¢ã‚’ä½¿ã£ã¦ä½œã‚‰ã‚Œã¦ã„ã¾ã™ã€‚âš¡ï¸

- 0 means the gate is closed and there is no electricity flowing ğŸ”´
- 0ã¯ã‚²ãƒ¼ãƒˆãŒé–‰ã¾ã£ã¦ã„ã¦é›»æ°—ãŒæµã‚Œã¦ã„ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ğŸ”´ã€‚
- 1 means the gate is open and there is electricity flowing ğŸŸ¢
- 1ã¯ã‚²ãƒ¼ãƒˆãŒé–‹ã„ã¦ã„ã¦é›»æ°—ãŒæµã‚Œã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ğŸŸ¢ã€‚

This is how you **count** in binary.<br/> Notice that everytime you run of digits (when you reach 1 actually), you increase by 1 on the left and restart counting from 0 at the right most digit.

ã“ã‚ŒãŒ2é€²æ³•ã§ã® **æ•°ãˆæ–¹** ã§ã™ã€‚<br/>æ¡ãŒè¶³ã‚Šãªããªã‚‹ãŸã³ã«ï¼ˆå®Ÿéš›ã«ã¯1ã«ãªã‚‹ã¨ãã«ï¼‰ã€å·¦ã‹ã‚‰1ãšã¤å¢—ãˆã¦ã„ãã€ä¸€ç•ªå³ã®æ¡ã§0ã‹ã‚‰æ•°ãˆå§‹ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

ğŸ’¡ The method to count is the same as in the decimal system it's just that instead of havings 10 digits we only use 2 digits <br/>
ğŸ’¡æ•°ãˆæ–¹ã¯10é€²æ³•ã¨åŒã˜ã§ã€10æ¡ã®ä»£ã‚ã‚Šã«2æ¡ã‚’ä½¿ã†ã ã‘ã§ã™ã€‚<br/>

<table style="min-width:500px;font-size:1em">
			<tbody><tr>
				<td>Decimal</td>
				<td>Binary</td>
			</tr>
			<tr>
				<td>0</td>
				<td>0000</td>
			</tr>
			<tr>
				<td>1</td>
				<td>0001</td>
			</tr>
			<tr>
				<td>2</td>
				<td>0010</td>
			</tr>
			<tr>
				<td>3</td>
				<td>0011</td>
			</tr>
			<tr>
				<td>4</td>
				<td>0100</td>
			</tr>
			<tr>
				<td>5</td>
				<td>0101</td>
			</tr>
			<tr>
				<td>6</td>
				<td>0110</td>
			</tr>
			<tr>
				<td>7</td>
				<td>0111</td>
			</tr>
			<tr>
				<td>8</td>
				<td>1000</td>
			</tr>
			<tr>
				<td>9</td>
				<td>1001</td>
			</tr>
			<tr>
				<td>10</td>
				<td>1010</td>
			</tr>
			<tr>
				<td>11</td>
				<td>1011</td>
			</tr>
			<tr>
				<td>12</td>
				<td>1100</td>
			</tr>
			<tr>
				<td>13</td>
				<td>1101</td>
			</tr>
			<tr>
				<td>14</td>
				<td>1110</td>
			</tr>			
			<tr>
				<td>15</td>
				<td>1111</td>
			</tr>
</tbody></table>

This time each digit represents a **power** of 2.

ã“ã®ã¨ãã€å„æ¡ã¯2ã®**ä¹—**ã‚’è¡¨ã—ã¾ã™ã€‚

1110 = 1 x 2<sup>3</sup> + 1 x 2<sup>2</sup> + 1 x 2<sup>1</sup> + 1 x 2<sup>0</sup> = 1 x 8 + 1 x 4 + 1 x 2 + 0 x 1 = 8 + 4 + 2 = 14

(You can check the table : 1110 is indeed the **binary representation** of 14) !

(è¡¨ã§ç¢ºèªã§ãã¾ã™ï¼š1110ã¯14ã® **ãƒã‚¤ãƒŠãƒªè¡¨ç¾ **ã§ã™ï¼‰ï¼

# Nat 8

In Motoko, there is a type called <a href="https://smartcontracts.org/docs/base-libraries/Nat8.html" target="_blank"> **Nat 8** </a>. This type is different from the type <a href="https://smartcontracts.org/docs/base-libraries/Nat8.html" target="_blank"> **Nat** </a> that we've used on Day 1.
Motokoã«ã¯ã€<a href="https://smartcontracts.org/docs/base-libraries/Nat8.html" target="_blank">**Nat 8**</a> ã¨ã„ã†å‹ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚¿ã‚¤ãƒ—ã¯ã€1æ—¥ç›®ã«ä½¿ç”¨ã—ãŸ <a href="https://smartcontracts.org/docs/base-libraries/Nat8.html" target="_blank">**Nat**</a> ã¨ã„ã†ã‚¿ã‚¤ãƒ—ã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚


ğŸ’¡ 8-bits is also called a **byte**. This is a term that is often used make sure to remember it.
ğŸ’¡ 8ãƒ“ãƒƒãƒˆã¯ **byte** ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚ã‚ˆãä½¿ã‚ã‚Œã‚‹è¨€è‘‰ãªã®ã§ã€ã—ã£ã‹ã‚Šè¦šãˆã¦ãŠãã¾ã—ã‚‡ã†ã€‚


**Nat 8** uses only 8-bits to represent numbers. <br/> This means you can use this type to represent any number with a binary representation between 00000000 and 11111111.

**Nat 8**ã¯8ãƒ“ãƒƒãƒˆã ã‘ã§æ•°å­—ã‚’è¡¨ç¾ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ã“ã®å‹ã‚’ä½¿ã£ã¦ã€00000000ã‹ã‚‰11111111ã®é–“ã®2é€²æ•°è¡¨ç¾ã‚’æŒã¤ä»»æ„ã®æ•°ã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

 <details>
        <summary style="color:green"> ğŸ¤” What is the number represented by 11111111 ? ğŸ¤” 11111111ã§è¡¨ã•ã‚Œã‚‹æ•°å­—ã¯ä½•ã§ã—ã‚‡ã†ï¼Ÿ</summary>
         11111111 = 1 x 2 <sup>7</sup>  + 1 x 2 <sup>6</sup> + 1 x 2 <sup>5</sup> + 1 x 2 <sup>4</sup> + 1 x 2 <sup>3</sup> + 1 x 2 <sup>2</sup> + 1 x 2 <sup>1</sup> +  + 1 x 2 <sup>0</sup> = 1 x 128 + 1 x 64 + 1 x 32 + 1 x 16 + 1 x 8 + 1 x 4 + 1 x 2 + 1 x 1 = <strong> 255 </strong>.
		 <br/> <br/>
		 <p> The maximum number we can represent with the type Nat8 is 255. </p>
                 <p> Nat8å‹ã§è¡¨ç¾ã§ãã‚‹æœ€å¤§ã®æ•°å€¤ã¯255ã§ã™ã€‚</p>
    </details>
	<br/>

Copy and paste the following actor declation and try deploying the actor.

ä»¥ä¸‹ã®ã‚¢ã‚¯ã‚¿ãƒ¼å®£è¨€ã‚’ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ã€ã‚¢ã‚¯ã‚¿ãƒ¼ã®ãƒ‡ãƒ—ãƒ­ã‚¤ã‚’è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚


```
actor {

  let a : Nat8 = 256;

};
```

You will get this error. Again this is because there is no way to represent the number 256 with only 8 bits !

ã“ã‚“ãªã‚¨ãƒ©ãƒ¼ãŒå‡ºã¾ã™ã€‚ã“ã‚Œã‚‚ã€256ã¨ã„ã†æ•°å­—ã‚’8ãƒ“ãƒƒãƒˆã§è¡¨ç¾ã™ã‚‹æ–¹æ³•ãŒãªã„ã‹ã‚‰ã§ã™ã€‚

```
type error [M0048], literal out of range for type Nat8
```

You can always convert a **Nat 8** to a **Nat** using the following code.

ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚Œã°ã€ã„ã¤ã§ã‚‚**Nat 8**ã‚’**Nat**ã«å¤‰æ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚


```
import Nat8 "mo:base/Nat8";

actor {

    public func nat8_to_nat(n : Nat8) : async Nat {
      return(Nat8.toNat(n));
    };

};
```

In Motoko there are also the types : **Nat 16**, **Nat 32** and **Nat 64**. <br/> Those are similar types to **Nat 8** expect they use respectively 16-bits, 32-bits and 64-bits, so they can represent way larger numbers.

Motoko ã«ã¯ã€ä»¥ä¸‹ã®å‹ã‚‚ã‚ã‚Šã¾ã™ : **Nat 16**, **Nat 32** and **Nat 64**<br/> ã“ã‚Œã‚‰ã¯ã€**Nat 8**ã¨ä¼¼ãŸã‚ˆã†ãªå‹ã§ã™ãŒã€ãã‚Œãã‚Œ16ãƒ“ãƒƒãƒˆã€32ãƒ“ãƒƒãƒˆã€64ãƒ“ãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã®ã§ã€ã‚ˆã‚Šå¤§ããªæ•°ã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

 <details>
        <summary style="color:green"> ğŸ¤” What is the maximum number represented by Nat32 ? ğŸ¤” Nat32ã§è¡¨ã•ã‚Œã‚‹æœ€å¤§ã®æ•°ã¯ä½•ã§ã—ã‚‡ã†ã‹ï¼Ÿ</summary>
		<br/>
		 <p> The maximum number we can represent with the type Nat32 is 4,294,967,295. Nat32å‹ã§è¡¨ç¾ã§ãã‚‹æœ€å¤§æ•°ã¯4,294,967,295ã§ã‚ã‚‹ã€‚</p>
    </details>
<br/>

The **Nat** type is unbounded, there is no upper limit to the maximum value it can represents. <br/>
Nat** å‹ã¯ unbounded ã§ã‚ã‚Šã€è¡¨ç¾ã§ãã‚‹æœ€å¤§å€¤ã«ä¸Šé™ã¯ãªã„ã€‚<br/>
You might be wondering why do we use **Nat 8/16/32/64** if we can always use **Nat** instead ? <br/>
ãªãœã€**Nat 8/16/32/64**ã‚’ä½¿ã†ã®ã ã‚ã†ã‹ã¨ç–‘å•ã«æ€ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚<br/>

This is for memory and efficiency reasons, the less bits we take to represent a number the more memory we save, and memory is expensive ! <br/> <br/>
If you know with assurance that your number will stay in a certain range (maybe because it's a constant) you can use the corresponding type to save memory. However if you have any doubt (because the value might change during your program execution) use a **Nat** and you will be safe.

ã“ã‚Œã¯ãƒ¡ãƒ¢ãƒªã¨åŠ¹ç‡ã®ãŸã‚ã§ã€æ•°å€¤ã‚’è¡¨ç¾ã™ã‚‹ãƒ“ãƒƒãƒˆãŒå°‘ãªã„ã»ã©ãƒ¡ãƒ¢ãƒªã‚’ç¯€ç´„ã§ãã¾ã™ã—ã€ãƒ¡ãƒ¢ãƒªã¯é«˜ä¾¡ã§ã™ <br/> <br/>
ã‚‚ã—ã€æ•°å€¤ãŒã‚ã‚‹ç¯„å›²ã«åã¾ã‚‹ã“ã¨ãŒç¢ºå®Ÿã«åˆ†ã‹ã£ã¦ã„ã‚‹å ´åˆï¼ˆå®šæ•°ã ã‹ã‚‰ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼‰ã€ãƒ¡ãƒ¢ãƒªã‚’ç¯€ç´„ã™ã‚‹ãŸã‚ã«å¯¾å¿œã™ã‚‹å‹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€ï¼ˆãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œä¸­ã«å€¤ãŒå¤‰ã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ï¼‰å°‘ã—ã§ã‚‚ç–‘å•ãŒã‚ã‚‹å ´åˆã¯ã€**Nat**ã‚’ä½¿ãˆã°å®‰å…¨ã§ã™ã€‚


# Challenge èª²é¡ŒğŸ®

Take a break and try completing challenge 1 to 3.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸1ï½3ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

# Unicode & ASCII ğŸ“š

Now that you've understood that we can represent any number using binary, you might be wondering : what about letters and characters ? ğŸ¤”

ã©ã‚“ãªæ•°å­—ã‚‚2é€²æ•°ã§è¡¨ç¾ã§ãã‚‹ã“ã¨ãŒç†è§£ã§ããŸã¨æ€ã„ã¾ã™ãŒã€ã“ã“ã§æ°—ã«ãªã‚‹ã®ãŒ : æ–‡å­—ã‚„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¯ã©ã†ãªã‚‹ï¼ŸğŸ¤”

We can decide to associate any character with a number and then encode the number as we've seen in the previous paragraph. <br/>
Let's say we decide to encode **A** with the number **65**. This is how it would be converted to binary.

å‰é …ã§è¦‹ãŸã‚ˆã†ã«ã€ä»»æ„ã®æ–‡å­—ã¨æ•°å­—ã®é–¢é€£ä»˜ã‘ã‚’æ±ºã‚ã¦ã€ãã®æ•°å­—ã‚’ç¬¦å·åŒ–ã™ã‚Œã°ã‚ˆã„ã®ã§ã™ã€‚<br/>
ä¾‹ãˆã°ã€**A** ã‚’**65** ã¨ã„ã†æ•°å­—ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ã«ã—ãŸã¨ã—ã¾ã™ã€‚ã“ã‚Œã‚’2é€²æ•°ã«å¤‰æ›ã™ã‚‹ã¨ã€ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

**A** --> **65** --> **01000001**.

We could use this method for all characters, we just need to associate each character that we use with a different number.

ã“ã®æ–¹æ³•ã¯ã™ã¹ã¦ã®æ–‡å­—ã«ä½¿ãˆã‚‹ã®ã§ã€ä½¿ç”¨ã™ã‚‹æ–‡å­—ã”ã¨ã«ç•°ãªã‚‹ç•ªå·ã‚’é–¢é€£ä»˜ã‘ã‚‹ã ã‘ã§ã‚ˆã„ã®ã§ã™ã€‚

Luckily we don't need to create our standard because we already have something called **ASCII** (American Standard Code For Information Interchange) : this is the first standard that was used to encode characters. Here's a table which associate characters with their representation.

å¹¸ã„ãªã“ã¨ã«ã€ç§ãŸã¡ã¯ç‹¬è‡ªã®è¦æ ¼ã‚’ä½œã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã™ã§ã« **ASCII** (American Standard Code For Information Interchange) ã¨ã„ã†ã‚‚ã®ãŒã‚ã‚Šã€ã“ã‚Œã¯æ–‡å­—ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚ŒãŸæœ€åˆã®è¦æ ¼ã§ã™ã€‚ã“ã“ã«ã€æ–‡å­—ã¨ãã®è¡¨ç¾ã‚’é–¢é€£ä»˜ã‘ãŸè¡¨ãŒã‚ã‚Šã¾ã™ã€‚

<br/>
<br/>

<p align="center"> <img src="img/ascii.png" width="600"/> </p>

**Capital letters** (A,B,C ... Z) are represented by decimals numbers starting from 65 to 90. <br/>
****å¤§æ–‡å­—**ï¼ˆA,B,C ... Zï¼‰ã¯ã€65ã‹ã‚‰90ã¾ã§ã®10é€²æ•°ã§è¡¨ã—ã¾ã™ã€‚
**Small letters** (a,b,c ... z) are represented by decimals from 97 to 122. <br/>
**å°ã•ãªæ–‡å­—**ï¼ˆa,b,c ... zï¼‰ã¯ã€97ã‹ã‚‰122ã¾ã§ã®å°æ•°ã§è¡¨ã—ã¾ã™ã€‚<br/>

ğŸ’¡ Notice that **numbers** from 0 to 9 are also represented from 48 to 59. This simply means the textual version of those numbers are represented using another number.

ğŸ’¡ 0ã‹ã‚‰9ã¾ã§ã®æ•°å­—**ã¯ã€48ã‹ã‚‰59ã¾ã§ã®æ•°å­—ã§ã‚‚è¡¨ç¾ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯å˜ã«ã€ãã‚Œã‚‰ã®æ•°å­—ã®ãƒ†ã‚­ã‚¹ãƒˆç‰ˆãŒã€åˆ¥ã®æ•°å­—ã‚’ä½¿ã£ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚

ASCII is an american standard that uses only 7-bits : it can encode only 128 characters. <br/> This is fine for most English character, numbers and punctuations but this is pretty limited. <br/> <br/>
We have since moved to **Unicode** which is, to put it short, an improved version of ASCII, that also takes into account characters from other languages, emojis... but even using Unicode (which is what is used in Motoko), ASCII table are still valid (this is because Unicode is compatible with ASCII).

ASCIIã¯ã‚¢ãƒ¡ãƒªã‚«ã®æ¨™æº–è¦æ ¼ã§ã€7ãƒ“ãƒƒãƒˆã—ã‹ä½¿ã‚ãªã„ã®ã§ã€128æ–‡å­—ã—ã‹ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã€‚<br/>ã“ã‚Œã¯ã€ã»ã¨ã‚“ã©ã®è‹±å­—ã€æ•°å­—ã€å¥èª­ç‚¹ã«ã¯é©ã—ã¦ã„ã¾ã™ãŒã€ã‹ãªã‚Šé™å®šçš„ã§ã™ã€‚<br/><br/>
ãã®å¾Œã€**Unicode**ã«ç§»è¡Œã—ã¾ã—ãŸãŒã€ã“ã‚Œã¯ç°¡å˜ã«è¨€ã†ã¨ã€ASCIIã®æ”¹è‰¯ç‰ˆã§ã€ä»–ã®è¨€èªã®æ–‡å­—ã‚„çµµæ–‡å­—ã‚‚è€ƒæ…®ã•ã‚Œã¦ã„ã¾ã™...ãŒã€Unicodeã‚’ä½¿ç”¨ã—ã¦ã‚‚ï¼ˆMotokoã§ã¯ã“ã‚Œã‚’ä½¿ç”¨ï¼‰ã€ASCIIãƒ†ãƒ¼ãƒ–ãƒ«ã¯æœ‰åŠ¹ã§ã™ï¼ˆã“ã‚Œã¯UnicodeãŒASCIIã¨äº’æ›æ€§ãŒã‚ã‚‹ã‹ã‚‰ã§ã™ï¼‰ã€‚

# Char & Text ğŸ’¬

A value of type **Text** is composed of multiples **Char**.

Text** å‹ã®å€¤ã¯ã€è¤‡æ•°ã® **Char** ã§æ§‹æˆã•ã‚Œã¾ã™ã€‚

```
let a : Text = "Hello";
let b : Char = 'c';
```

Char values are delimited using **' '** whereas we use **" "** for Text.
You can loop through all characters of a Text value using **.chars()** as in the following expression :

æ–‡å­—åˆ—ã¯ **' '** ã§åŒºåˆ‡ã‚‰ã‚Œã¾ã™ãŒã€æ–‡å­—åˆ—ã«ã¯ **" "** ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
ä»¥ä¸‹ã®å¼ã®ã‚ˆã†ã«ã€**.chars()** ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€Textå€¤ã®ã™ã¹ã¦ã®æ–‡å­—ã‚’ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```
let a : Text = "Motoko bootcamp";
for(char in a.chars()){
	//Do something
};
```

You can also access the size (number of characters) of a Text value using **.size()** <br/>

ã¾ãŸã€Textå€¤ã®ã‚µã‚¤ã‚ºï¼ˆæ–‡å­—æ•°ï¼‰ã¯ã€**.size()** ã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ <br/>

```
actor {
	// Return the number of characters in the text
	public func number_characters(t : Text) : async Nat {
		return(t.size());
	};
};

```

You can also concatenate multiples values of type Text together using the concatenation operator : **#**.

ã¾ãŸã€é€£çµæ¼”ç®—å­ã‚’ä½¿ã£ã¦ã€Textå‹ã®è¤‡æ•°ã®å€¤ã‚’é€£çµã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚: **#**.


```
let a : Text = "Hello";
let b : Text = "World";
let c : Text = a # " " # b; // "Hello World"

```

Finaly let's take a brief look at what Unicode looks in practice. Copy and paste this actor declaration and deploy it on your local replica.

æœ€å¾Œã«ã€UnicodeãŒå®Ÿéš›ã«ã©ã®ã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã€ç°¡å˜ã«è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã“ã®ã‚¢ã‚¯ã‚¿ãƒ¼å®£è¨€ã‚’ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ»ãƒ¬ãƒ—ãƒªã‚«ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ãã ã•ã„ã€‚

```

import Char "mo:base/Char";
actor {
    //	Return the character corresponding to the unicode value n.
    public func unicode_to_character(n : Nat32) : async Text {
    	let char : Char = Char.fromNat32(n);
    	return(Char.toText(char));
    };
};

```

 <details>
        <summary style="color:green"> ğŸ¤” What should the command : <strong> dfx canister call day_2 unicode_to_character '(63)' </strong> return ? ğŸ¤” ã‚³ãƒãƒ³ãƒ‰ : <strong> dfx canister call day_2 unicode_to_character '(63)' </strong> ã¯ä½•ã‚’è¿”ã™ã¹ããªã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ</summary>
		<br/>
		 <p> Looking at the ASCII table : the decimal number 63 corresponds to the encoding of the character  <strong> ? </strong>. This is what the command will return (try it!) </p>
ASCIIè¡¨ã‚’è¦‹ã‚‹ã¨ã€10é€²æ•°ã§63ãŒæ–‡å­— <strong>?</strong> ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã«ç›¸å½“ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚³ãƒãƒ³ãƒ‰ãŒè¿”ã™ã‚‚ã®ã§ã™ (è©¦ã—ã¦ã¿ã¦ãã ã•ã„!)
    </details>
<br/>

# Challenge

Take a break and try completing challenge 4 to 6.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸4ï½6ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ã¯ã„ã‹ãŒã§ã—ã‚‡ã†ã‹ã€‚

# Candid & WebAssembly ğŸ§‘â€ğŸ”¬

If you take a close look at the previous actor declaration you might be wondering why we needed to convert the **char** value to a **Text** type on the last line, if the goal was only to get a character from an unicode value why not directly return it ?

å‰ã®ã‚¢ã‚¯ã‚¿ãƒ¼å®£è¨€ã‚’ã‚ˆãè¦‹ã‚‹ã¨ã€ãªãœæœ€å¾Œã®è¡Œã§ **char** å‹ã®å€¤ã‚’ **Text** å‹ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã‹ã€ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰å€¤ã‹ã‚‰æ–‡å­—ã‚’å–å¾—ã™ã‚‹ã“ã¨ã ã‘ãŒç›®çš„ãªã‚‰ã€ãªãœãã‚Œã‚’ç›´æ¥è¿”ã•ãªã„ã®ã‹ã¨æ€ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã­ï¼Ÿ

Let's try it out. Copy and paste the following actor declaration and deploy it on your local replica.

è©¦ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ä»¥ä¸‹ã®ã‚¢ã‚¯ã‚¿ãƒ¼å®£è¨€ã‚’ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¬ãƒ—ãƒªã‚«ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ãã ã•ã„ã€‚

```
import Char "mo:base/Char";
actor {
    //	Return the character corresponding to the unicode value n.
    public func unicode_to_character(n : Nat32) : async Char {
    	let char : Char = Char.fromNat32(n);
    	return(char));
    };
};
```

This code is totally valid... but you might be surprised at what the following command will return

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯å®Œå…¨ã«æœ‰åŠ¹ã§ã™...ã—ã‹ã—ã€æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ãŒè¿”ã™å†…å®¹ã«ã¯é©šãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

```
dfx canister call day_2 unicode_to_character '(63)'
(63 : nat32)
```

Why are we getting a value of type **Nat 32** when we the return type of the function is **Char** ?

é–¢æ•°ã®æˆ»ã‚Šå€¤ã®å‹ã¯ **Char** ã§ã‚ã‚‹ã®ã«ã€ãªãœ **Nat 32** å‹ã®å€¤ãŒè¿”ã•ã‚Œã‚‹ã®ã§ã™ã‹ï¼Ÿ

To answer this question : we need to take a step back and explain severals things before.

ã“ã®å•ã„ã«ç­”ãˆã‚‹ã«ã¯ã€ä¸€æ­©ä¸‹ãŒã£ã¦ã€ã„ãã¤ã‹ã®äº‹æŸ„ã‚’èª¬æ˜ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

- Contrary to what you might believe : the language that is powering canisters on the Internet Computer is **not** Motoko. You've been lied to. <br/> Motoko is used to compile (translate) your code into another language called **Web Assembly** (WASM) which is what is ultimately deployed on the IC. <br/> <br/>
- ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‚’å‹•ã‹ã—ã¦ã„ã‚‹è¨€èªã¯ã€Motoko ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚ãªãŸã¯é¨™ã•ã‚Œã¦ã„ã‚‹ã®ã§ã™ã€‚Motokoã¯ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã‚’**Web Assembly** (WASM)ã¨å‘¼ã°ã‚Œã‚‹åˆ¥ã®è¨€èªã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ï¼ˆç¿»è¨³ï¼‰ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã€æœ€çµ‚çš„ã«ICä¸Šã«é…ç½®ã•ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚
- Web Assembly is a **low level** language. We have said earlier that the machine only understand binary but we do not write code in binary, we use different languages of programmation (Motoko, Rust, Javascript, C, Java ...) those languages are **high level**, this means their are closer to a human language than machine instructions.
- Webã‚¢ã‚»ãƒ³ãƒ–ãƒªã¯ **ä½ãƒ¬ãƒ™ãƒ«** ã®è¨€èªã§ã™ã€‚æ©Ÿæ¢°ã¯ãƒã‚¤ãƒŠãƒªã—ã‹ç†è§£ã§ããªã„ã¨è¨€ã„ã¾ã—ãŸãŒã€ç§ãŸã¡ã¯ãƒã‚¤ãƒŠãƒªã§ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã¾ã›ã‚“ã€‚ç§ãŸã¡ã¯ã•ã¾ã–ã¾ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªï¼ˆMotokoã€Rustã€Javascriptã€Cã€Javaãªã©ï¼‰ã‚’ä½¿ã£ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã‚‰ã®è¨€èªã¯**é«˜ãƒ¬ãƒ™ãƒ«**ã§ã€æ©Ÿæ¢°èªã‚ˆã‚Šã‚‚äººé–“ã®è¨€èªã«è¿‘ã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚

<p align="center"> <img src="img/language.png" width="400"/> </p>

- A canister is similar to a container that contains the code and memory for your program : all canisters whether they were written in Motoko, in Rust or in another language are ultimately Web Assembly module.
- ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚³ãƒ¼ãƒ‰ã¨ãƒ¡ãƒ¢ãƒªã‚’æ ¼ç´ã™ã‚‹å®¹å™¨ã«ä¼¼ã¦ã„ã¾ã™ã€‚Motokoã€Rustã€ãã®ä»–ã®è¨€èªã§æ›¸ã‹ã‚ŒãŸã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ã€æœ€çµ‚çš„ã«Web Assemblyãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ãªã‚Šã¾ã™ã€‚

<p align="center"> <img src="img/canister.png" width="400"/> </p>

- We need a way to being able to communicate between canister and applications written in differents languages. Let's imagine you are writting your code in Motoko and you want to be able to send a message to a canister written in Rust, how do you know how to communicate with this canister ? <br/> This is exactly like trying to speak Spanish to someone that is expecting to listen to Chinese ğŸ‡ªğŸ‡¸ ğŸ‡¨ğŸ‡³. <br/>
- ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¨ç•°ãªã‚‹è¨€èªã§æ›¸ã‹ã‚ŒãŸã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é–“ã§é€šä¿¡ã§ãã‚‹æ–¹æ³•ãŒå¿…è¦ã§ã™ã€‚ä¾‹ãˆã°ã€ã‚ãªãŸãŒMotokoã§ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã„ã¦ã€Rustã§æ›¸ã‹ã‚ŒãŸcanisterã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚Œã‚‹ã‚ˆã†ã«ã—ãŸã„ã¨ã—ã¾ã—ã‚‡ã†ã€‚<br/>ã“ã‚Œã¯ã¾ã•ã«ã€ä¸­å›½èª ã‚’æœŸå¾…ã—ã¦ã„ã‚‹äººã«ã‚¹ãƒšã‚¤ãƒ³èªã‚’è©±ãã†ã¨ã™ã‚‹ã‚ˆã†ãªã‚‚ã®ã§ã™ ğŸ‡ªğŸ‡¸ ğŸ‡¨ğŸ‡³ ã€‚<br/>

- On the Internet Computer we have a **common** language ğŸŒ : it's called **Candid**. This is an **interface description language (IDL)** : it's primary purpose is to describe the interface of a canister so everyone knows what to expect from this canister. Here's what it looks like for a simple **counter**.
- ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«ã¯ã€**å…±é€š**è¨€èªğŸŒãŒã‚ã‚Šã¾ã™ï¼šãã‚Œã¯**Candid**ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨˜è¿°è¨€èª(IDL)** ã§ã€ãã®ä¸»ãªç›®çš„ã¯ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ã§ã€èª°ã‚‚ãŒã“ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‹ã‚‰ä½•ã‚’æœŸå¾…ã™ã‚Œã°ã‚ˆã„ã‹ã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã¯ã€å˜ç´”ãª**ã‚«ã‚¦ãƒ³ã‚¿**ã®ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚

<p align="center"> <img src="img/candid.png" width="600"/> </p>

As you can see, it describes the function you can access (the **public** function in Motoko) and the type of parameters and return values.

ã”è¦§ã®ã‚ˆã†ã«ã€ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹é–¢æ•°ï¼ˆMotokoã§ã¯**public**é–¢æ•°ï¼‰ã¨ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨æˆ»ã‚Šå€¤ã®å‹ãŒè¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚

- When you are using dfx to talk to a canister you are specifying values in a Candid format, the answer is also in Candid format.
- dfxã‚’ä½¿ç”¨ã—ã¦ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¨å¯¾è©±ã™ã‚‹å ´åˆã€Candidå½¢å¼ã§å€¤ã‚’æŒ‡å®šã—ã¾ã™ãŒã€ãã®ç­”ãˆã‚‚Candidå½¢å¼ã§ã™ã€‚


```
dfx canister call day_2 unicode_to_character '(63)' <- Candid
```

Although Candid types and Motoko types are quite close, they are not the same. <br/>
In Candid there is no **Char** type, this type only exists within the Motoko code. For Candid a **Char** is abstracted as a **nat32**.

Candid å‹ã¨ãƒ¢ãƒˆã‚³ãƒ¼å‹ã¯ã‹ãªã‚Šè¿‘ã„ã®ã§ã™ãŒã€åŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚<br/>
Candid ã«ã¯ **Char** ã¨ã„ã†å‹ã¯ãªãã€ã“ã®å‹ã¯Motokoã®ã‚³ãƒ¼ãƒ‰å†…ã«ã®ã¿å­˜åœ¨ã—ã¾ã™ã€‚ã‚­ãƒ£ãƒ³ãƒ‡ã‚£ãƒƒãƒ‰ã§ã¯ **Char** ã¯ **nat32** ã¨ã—ã¦æŠ½è±¡åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚

```
actor {
	public func test() : async Char {
		return('1');
	};
};
```

This is why the previous actor declaration, once deployed will return the following.

ã“ã®ãŸã‚ã€å…ˆã»ã©ã®ã‚¢ã‚¯ã‚¿ãƒ¼å®£è¨€ã¯ã€ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«è¿”ã•ã‚Œã¾ã™ã€‚

```
dfx canister call day_2 test '()'
(49 : nat32)
```

The '1' **Char** in Motoko is equivalent to the 49 **nat 32** of Candid (due to the Unicode representation of 1).

Motoko ã® '1' **Char** ã¯ Candid ã® 49 **nat 32** ã«ç›¸å½“ã—ã¾ã™ (1 ã® Unicode è¡¨ç¾ã«ã‚ˆã‚‹)ã€‚

# Challenge ğŸ®

Take a break and try completing challenge 7 to 10.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸7ï½10ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ãã ã•ã„ã€‚
