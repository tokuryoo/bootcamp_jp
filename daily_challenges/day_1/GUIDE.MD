# Daily guide : day 1 ğŸ¥š

Welcome into the first day of the Motoko Bootcamp ! <br/>
This guide is meant to cover some basics on : **Actor**, **function**, **types**,**variables**, **loops** and **modules**.

Motoko Bootcampã®åˆæ—¥ã‚’è¿ãˆã¾ã—ãŸï¼<br/>
ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã¯ã€ä»¥ä¸‹ã®åŸºæœ¬çš„ãªäº‹æŸ„ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚: **Actor**, **function**, **types**,**variables**, **loops** and **modules**.

# Prerequisites âœ…

- Check you have dfx installed on your machine.
- dfxãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚

  ```
  dfx --version
  ```

- Start a new project called **day_1** and turn on your local replica.
- æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ **day_1** ã‚’é–‹å§‹ã—ã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¬ãƒ—ãƒªã‚«ã‚’ã‚ªãƒ³ã«ã—ã¾ã™ã€‚

  ```
  dfx new day_1
  cd day_1
  dfx start
  ```

# Motoko ğŸ‘»

Motoko is a language that has been developed by the **Dfinity** foundation specifically for the Internet Computer. </br>

A motoko file is a file with the indication .mo at the end.

Let's create a new project with dfx using the command :

Motokoã¯ã€**Dfinity**è²¡å›£ãŒã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ãŸã‚ã«ç‰¹åˆ¥ã«é–‹ç™ºã—ãŸè¨€èªã§ã™ã€‚ </br>

motokoãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€æœ«å°¾ã«.moã®è¡¨ç¤ºãŒã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚

dfxã§æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’.moã‚³ãƒãƒ³ãƒ‰ã§ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚


```
dfx create hello
```

You can open the new project with your IDE (Visual Studio Code or other) and you will notice inside src/hello a file called main.mo : this is a motoko file.

IDE (Visual Studio Code ãªã©) ã§æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é–‹ãã¨ã€src/hello ã®ä¸­ã« main.mo ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ã“ã¨ã«æ°—ã¥ãã§ã—ã‚‡ã†ã€‚

<p align="center"> <img src="img/file.png" width="300"/> </p>

# Actor ğŸ¤–

If you open the main.mo file you will notice that the first word is **actor**.

main.moãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã¨ã€æœ€åˆã®å˜èªãŒ **actor** ã§ã‚ã‚‹ã“ã¨ã«æ°—ã¥ãã ã‚ã†ã€‚


```
actor {

};
```

An **actor** is simply the representation of a canister for the Motoko language.

On the Internet Computer each canister is separated from all other canisters and can only communicate with other canister through **asynchronous** messages. ğŸ“­

**ã‚¢ã‚¯ã‚¿ãƒ¼** ã¨ã¯ã€ç°¡å˜ã«è¨€ãˆã°ã€ãƒ¢ãƒˆã‚¯ãƒ­ã‚¹è¨€èªã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‚’è¡¨ç¾ã—ãŸã‚‚ã®ã§ã™ã€‚

ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§ã¯ã€å„ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ä»–ã®ã™ã¹ã¦ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‹ã‚‰åˆ†é›¢ã•ã‚Œã¦ãŠã‚Šã€ä»–ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¨ã¯ **éåŒæœŸ** ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€šã˜ã¦ã®ã¿é€šä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ğŸ“­


# Function âš™ï¸

This actor has only one function called **greet**. <br/>

ã“ã®ã‚¢ã‚¯ã‚¿ãƒ¼ã¯ã€**greet** ã¨ã„ã†1ã¤ã®æ©Ÿèƒ½ã—ã‹æŒã£ã¦ã„ã¾ã›ã‚“ã€‚<br/>


```
actor {

    public func greet(name : Text) : async Text {
        return "Hello, " # name # "!";
    };
};

```

## Public / Private

Notice that this function is **public** : it means it can be called by other actors and by users on the Internet Computer. âœ… <br/>

You will see later that function can sometimes be **private** (in that case it can only be called by the actor himself and not by external entities). â›”ï¸

ã“ã®é–¢æ•°ã¯ **public** ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ : ã“ã‚Œã¯ã€ä»–ã®ã‚¢ã‚¯ã‚¿ãƒ¼ã‚„ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆä¸Šã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ Computerã€‚âœ… <br/>

é–¢æ•°ãŒ **private** ã§ã‚ã‚‹å ´åˆã‚‚ã‚ã‚‹ã“ã¨ã¯å¾Œã§èª¬æ˜ã—ã¾ã™ï¼ˆãã®å ´åˆã€ã‚¢ã‚¯ã‚¿ãƒ¼è‡ªèº«ã«ã‚ˆã£ã¦ã®ã¿å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã€å¤–éƒ¨ã‹ã‚‰ã¯å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã›ã‚“ï¼‰ã€‚â›”ï¸

## Argument & Return value

The next thing you should notice is the **argument** of the function greet : the argument here is called name and is of type **Text**.

æ¬¡ã«æ³¨ç›®ã™ã¹ãã¯ã€é–¢æ•°greetã®**å¼•æ•°**ã§ã€ã“ã“ã§ã¯nameã¨å‘¼ã°ã‚Œã€**Text** ã¨ã„ã†å‹ã«ãªã£ã¦ã„ã¾ã™ã€‚

The return value of this function is of type **async Text**. <br/> This means that the person or canister calling will have to **await** to get the result. â±

ã“ã®é–¢æ•°ã®æˆ»ã‚Šå€¤ã¯ã€**async Text** å‹ã§ã™ã€‚<br/> ã“ã‚Œã¯ã€å‘¼ã³å‡ºã—ãŸäººã¾ãŸã¯ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒçµæœã‚’å–å¾—ã™ã‚‹ãŸã‚ã« **å¾…æ©Ÿ** ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚â±

To understand this concept you need to imagine what it means to be a canister on the Internet Computer : at any moment an user or an other canister can call you through any of your **public** function.

ã“ã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’ç†è§£ã™ã‚‹ãŸã‚ã«ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ»ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã§ã‚ã‚‹ã“ã¨ã®æ„å‘³ã‚’æƒ³åƒã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

What if you were already answering a previous request ? You are a simple program you can only do one thing at a time : you need to finish what you are currently doing and **then** you will be able to process the incoming request. âš¡ï¸

ã‚‚ã—ã€ã‚ãªãŸãŒã™ã§ã«å‰ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ç­”ãˆã¦ã„ãŸã¨ã—ãŸã‚‰ã©ã†ã§ã—ã‚‡ã†ï¼Ÿã‚ãªãŸã¯ä¸€åº¦ã«ä¸€ã¤ã®ã“ã¨ã—ã‹ã§ããªã„å˜ç´”ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã™ã€‚ç¾åœ¨è¡Œã£ã¦ã„ã‚‹ã“ã¨ã‚’çµ‚ãˆã¦ã€**ãã‚Œã‹ã‚‰**ã€å…¥ã£ã¦ããŸè¦æ±‚ã‚’å‡¦ç†ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚âš¡ï¸


By specifying that the return value is of type **async Text** you indicate to anyone that if they call your **greet** function they will get back a **Text** value but they will have to wait a bit. ğŸ

æˆ»ã‚Šå€¤ãŒ **async Text** å‹ã§ã‚ã‚‹ã“ã¨ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€èª°ã§ã‚‚ã‚ãªãŸã® **greet** é–¢æ•°ã‚’å‘¼ã¹ã° **Text** å€¤ãŒæˆ»ã£ã¦ãã‚‹ãŒã€å°‘ã—å¾…ãŸãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã‚’ç¤ºã™ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ã€‚ğŸ

**Remember** : every **public** function of an actor has a return value that is **async**.

ã‚¢ã‚¯ã‚¿ãƒ¼ã®ã™ã¹ã¦ã® **public** é–¢æ•°ã¯ **async** ã®æˆ»ã‚Šå€¤ã‚’æŒã£ã¦ã„ã‚‹ã“ã¨ã‚’ **æ€ã„å‡ºã—ã¦ãã ã•ã„**ã€‚


## Calling a function

We can call the greet function using <a href="https://smartcontracts.org/docs/developers-guide/cli-reference/dfx-parent.html" target="\_blank"> dfx </a> by running the following commands in your terminal.

ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã€<a href="https://smartcontracts.org/docs/developers-guide/cli-reference/dfx-parent.html" target="\_blank"> dfx </a>ã‚’ä½¿ç”¨ã—ã¦greeté–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚


```
dfx deploy day_1
```

Once the canister has been deployed.

ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒãƒ‡ãƒ—ãƒ­ã‚¤ã•ã‚ŒãŸã‚‰

```
dfx canister call day_1 greet '("world")'
("Hello, world!")
```

**day_1** is the name of the canister.

**day_1** ã¯ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®åå‰ã§ã™ã€‚

**greet** is the function we are calling.

**greet** ã¯ã€ä»Šå›å‘¼ã³å‡ºã™é–¢æ•°ã§ã™ã€‚

<br/>
**"world"** is the argument we are sending.
Note : when using dfx you should put your argument(s) into **'( )'**.

**"world"** ã¯ã€é€ä¿¡ã™ã‚‹å¼•æ•°ã§ã™ã€‚
æ³¨æ„ : dfx ã‚’ä½¿ã†ã¨ãã¯ã€å¼•æ•°ã‚’ **'( )'** ã«å…¥ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
<br/>

**"Hello, world"** is the value returned by the function.

**"Hello, world"** ã¯ã€ã“ã®é–¢æ•°ãŒè¿”ã™å€¤ã§ã™ã€‚

More generally you can call any canister method with any argument, using this generic command.

ã‚ˆã‚Šä¸€èˆ¬çš„ã«ã¯ã€ã“ã®æ±ç”¨ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€ä»»æ„ã®å¼•æ•°ã§ä»»æ„ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚

```

dfx canister call <CANISTER_NAME> <METHOD_NAME> '(ARGUMENT)'

```

# Variables å¤‰æ•° ğŸ’¾

You can declare variables using the **let** keyword and the assignement operator : **=** .

å¤‰æ•°ã®å®£è¨€ã«ã¯ã€**let** ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨ä»£å…¥æ¼”ç®—å­ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ : **=** .

<br/> You can think of a variable has a box where you can store anything and access it later using the name of this variable. ğŸ“¦

å¤‰æ•°ã¨ã¯ã€ä½•ã‹ã‚’ä¿å­˜ã—ã¦ãŠãã€å¾Œã§ã“ã®å¤‰æ•°åã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®ç®±ã§ã‚ã‚‹ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ğŸ“¦

```
let a = 5;
let b = a + 3; // 8
```

By default variables are **immutables** in Motoko, this means that once a variable has been assigned a value you cannot change it. <br/>

Motokoã§ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§å¤‰æ•°ã¯**ä¸å¤‰**ã§ã™ã€‚ã“ã‚Œã¯ã€ä¸€åº¦å€¤ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸå¤‰æ•°ã¯ã€å¤‰æ›´ã§ããªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚

You can declare **mutable** variables using the **var** keyword.

**var** ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€**mutable** å¤‰æ•°ã‚’å®£è¨€ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```
var a = 5;
var b = a + 3; // 8
```

You can reassign a new value inside **mutable** variable with the reassignement operator : **:=**.

mutable** å¤‰æ•°ã®å†…éƒ¨ã«æ–°ã—ã„å€¤ã‚’ä»£å…¥ã™ã‚‹ã«ã¯ã€å†ä»£å…¥æ¼”ç®—å­ :  **:=**


```
var a = 5;  //  First declaration.
var a := 6; //  Reassignement to a new value.
```

Take a look at the following actor declaration ğŸ‘€.

æ¬¡ã®ã‚¢ã‚¯ã‚¿ãƒ¼å®£è¨€ğŸ‘€ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ ğŸ‘€.


```
actor {
    let a = 4;
    a := 5;
};
```

 <details>
        <summary style="color:green"> ğŸ¤”  What do you think would happen if we tried to deploy this actor ? ğŸ¤” ã“ã®ã‚¢ã‚¯ã‚¿ãƒ¼ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã‚ˆã†ã¨ã—ãŸã‚‰ã€ã©ã†ãªã‚‹ã¨æ€ã„ã¾ã™ã‹ï¼Ÿ</summary>
        <br/>
        This would result in an error, we are trying to reassign a <strong> mutable </strong> variable. The exact error is : <strong> <i> type error [M0073], expected mutable assignment target. </strong> </i>
        ã“ã‚Œã¯ã€<strong> mutable </strong> å¤‰æ•°ã‚’å†ä»£å…¥ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã€ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚æ­£ç¢ºãªã‚¨ãƒ©ãƒ¼ã¯ : <strong> <i> type error [M0073], expected mutable assignment target. </strong> </i> ã§ã™ã€‚
</details>
<br/>

# Types å‹ ğŸ

In Motoko, every variable has a type, to indicate the type we use the symbol <strong> : </strong> <br/> Here's a few examples of variable with their type and their value.

Motoko ã§ã¯ã€ã™ã¹ã¦ã®å¤‰æ•°ã«å‹ãŒã‚ã‚Šã€å‹ã‚’ç¤ºã™ãŸã‚ã« <strong> : </strong> ã¨ã„ã†è¨˜å·ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚<br/>
 ä»¥ä¸‹ã¯ã€å¤‰æ•°ã®å‹ã¨å€¤ã®ä¾‹ã§ã™ã€‚

```
let name : Text = "Motoko";

let age : Nat = "2";

let ghost : Bool = true;
```

In most cases, you can omit the type of a variable and Motoko will deduce it for you. For instance, if you declare a variable with this expression :
ã»ã¨ã‚“ã©ã®å ´åˆã€å¤‰æ•°ã®å‹ã‚’çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã€Motokoã¯ãã‚Œã‚’æ¨è«–ã—ã¦ãã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€ã“ã®ã‚ˆã†ãªå¼ã§å¤‰æ•°ã‚’å®£è¨€ã—ãŸå ´åˆã€:

```

let name = "Motoko";

```

Motoko will automatically know that this variable is of type **Text**. <br/>
However for the sake of clarity : I **strongly advise** you to use the the type of variables you are using and that's what we will do in the following lessons.

Motokoã¯è‡ªå‹•çš„ã«ã“ã®å¤‰æ•°ãŒ**Text**å‹ã§ã‚ã‚‹ã“ã¨ã‚’èªè­˜ã—ã¾ã™ã€‚<br/>
ã—ã‹ã—ã€ã‚ã‹ã‚Šã‚„ã™ãã™ã‚‹ãŸã‚ã«ã€ç§ã¯ã€ã‚ãªãŸãŒä½¿ã£ã¦ã„ã‚‹å¤‰æ•°ã®å‹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’å¼·ããŠå‹§ã‚ã—ã¾ã™ã€‚

# Error ã‚¨ãƒ©ãƒ¼ ğŸ˜µ

Motoko has strict rules around types, during this week you'll probably encounter a lot of **type errors**. ğŸ‘©â€âš–ï¸ <br/>

Motoko å‹ã«å³ã—ã„ã®ã§ã€ã“ã®ä¸€é€±é–“ã¯ **å‹ã‚¨ãƒ©ãƒ¼**ãŒ å¤šç™ºã—ãã†ã§ã™ã€‚ ğŸ‘©â€âš–ï¸ <br/>


One example of such an error would be to try to add two variables of different types. Let's try to add a **Text** with a **Nat**.

ã“ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ã®ä¸€ä¾‹ã¨ã—ã¦ã€ç•°ãªã‚‹å‹ã®2ã¤ã®å¤‰æ•°ã‚’è¿½åŠ ã—ã‚ˆã†ã¨ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€**Text**ã¨**Nat**ã‚’è¿½åŠ ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚


```

public func add_five(number : Text) : async Text {
    return (number + 5);
};

```

Trying to compile this code will result in an type error.

ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€å‹ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚

```

type error [M0050], literal of type
Nat
does not have expected type
Text

```

We will cover many types in details but for the moment try to remember that you should always keep an eye on what are the types of the variables you are using.

è©³ç´°ã¯ã“ã‚Œã‹ã‚‰èª¬æ˜ã—ã¾ã™ãŒã€ã¨ã‚Šã‚ãˆãšã€è‡ªåˆ†ãŒä½¿ã£ã¦ã„ã‚‹å¤‰æ•°ãŒã©ã®ã‚ˆã†ãªã‚¿ã‚¤ãƒ—ãªã®ã‹ã€å¸¸ã«æ³¨æ„ã—ã¦ãŠãã“ã¨ã‚’å¿ƒãŒã‘ã¦ãã ã•ã„ã€‚

# Nat and operations Nat ã¨ æ¼”ç®—å­ ğŸ§®

Let's start with the **Nat** type. This type is meant to represent any natural number. <br/>

ã¾ãšã€**Nat** å‹ã‹ã‚‰å§‹ã‚ã¾ã—ã‚‡ã†ã€‚ã“ã®å‹ã¯ä»»æ„ã®è‡ªç„¶æ•°ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚

Natural numbers are : 0,1,2,3 ... âˆ

è‡ªç„¶æ•°ã¨ã¯ï¼0,1,2,3 ... âˆ

## Addition åŠ ç®— â•

You can add two numbers using the addition operator **+**

åŠ ç®—æ¼”ç®—å­ **+** ã‚’ä½¿ã£ã¦ã€2ã¤ã®æ•°å€¤ã‚’è¶³ã™ã“ã¨ãŒã§ãã¾ã™ã€‚


```

let a : Nat = 1 + 1;

```

## Multiplication ä¹—ç®— âœ–ï¸

You can multiply two numbers using the multiplication operator : **\***

2ã¤ã®æ•°å­—ã‚’æ›ã‘åˆã‚ã›ã‚‹ã«ã¯ã€Multiplicationæ¼”ç®—å­ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚: **\***


```

let a : Nat = 10 * 10;

```

## Substraction æ¸›ç®— â–

You can substract two numbers using the substraction operator : **-**

2ã¤ã®æ•°å€¤ã‚’å¼•ãç®—ã™ã‚‹ã«ã¯ã€æ¸›ç®—æ¼”ç®—å­ : **-**

```

let a : Nat = 10 - 5;

```

â˜¢ï¸ Be careful when using substraction operator with the type Nat. â˜¢ï¸ <br/> <br/> The type **Nat** is composed of positive numbers only. <br/> If the result of the substraction is below 0, your value won't be of type Nat anymore and if your program if expecting a value of type **Nat** it might **trap**.

â˜¢ï¸ Natå‹ã«ã‚µãƒ–ãƒˆãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¼”ç®—å­ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚â˜¢ï¸ <br/> <br/> Nat** å‹ã¯æ­£ã®æ•°ã®ã¿ã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ã€‚ã‚‚ã—ã€æ¸›ç®—ã®çµæœãŒ0ä»¥ä¸‹ã§ã‚ã‚Œã°ã€ãã®å€¤ã¯ã‚‚ã†Natå‹ã§ã¯ãªãã€ã‚‚ã—ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒ**Nat**å‹ã®å€¤ã‚’æœŸå¾…ã—ã¦ã„ã‚‹ãªã‚‰ã°ã€**trap**ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚


```
actor {
    let a : Nat = 1 - 2;
};
```

Trying to deploy this actor would result in a **subtraction underflow** causing a **trap**..

ã“ã®ã‚¢ã‚¯ã‚¿ãƒ¼ã‚’é…ç½®ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€**subtraction underflow** ãŒç™ºç”Ÿã—ã€**trap** ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚

```
Error: The Replica returned an error: code 5, message: "Canister rrkah-fqaaa-aaaaa-aaaaq-cai trapped explicitly: Natural subtraction underflow"

ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚ãƒ¬ãƒ—ãƒªã‚«ã¯ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰5ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã—ã¾ã—ãŸã€‚"ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ rrkah-fqaaa-aaaaq-cai ãŒæ˜ç¤ºçš„ã«ãƒˆãƒ©ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸã€‚è‡ªç„¶æ¸›ç®—ã®ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼"

```

ğŸ’¡ A **trap** is an error that happen during the **execution** of a program, when a **trap** happen the execution of the programm is stopped and a, error message is returned.

ğŸ’¡ ãƒˆãƒ©ãƒƒãƒ—ã¨ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œä¸­ã«ç™ºç”Ÿã™ã‚‹ã‚¨ãƒ©ãƒ¼ã®ã“ã¨ã§ã€ãƒˆãƒ©ãƒƒãƒ—ãŒç™ºç”Ÿã™ã‚‹ã¨ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡ŒãŒåœæ­¢ã—ã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¿”ã•ã‚Œã¾ã™ã€‚


## Division & modulo é™¤ç®—ã¨ä½™ã‚Š â—

You can divide two numbers using the **division** operator : **/** .
<br>
You can get the remainder of a divided by b using the **modulo** operator : **%** .

2 ã¤ã®æ•°å€¤ã‚’å‰²ã‚Šç®—ã™ã‚‹ã«ã¯ã€**division** æ¼”ç®—å­ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚**/** .
<br>
a ã‚’ b ã§å‰²ã£ãŸä½™ã‚Šã¯ã€**modulo** æ¼”ç®—å­ã‚’ç”¨ã„ã¦æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚**%** .

```
let a : Nat = 10 / 2;
let b : Nat = 3 % 2;
```

In this case **a** equals **5** and **b** equals **1**.

ã“ã®å ´åˆã€**a**ã¯**5**ã«ã€**b**ã¯**1**ã«ç›¸å½“ã—ã¾ã™ã€‚

# Challenge ğŸ®

Take a break and try completing challenge 1 to 4.
ä¸€æ¯ã¤ã„ã¦ã‹ã‚‰ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸1ï½4ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

# Boolean and conditions ğŸŸ¢ ğŸ”´

Let's move on to a new type called **Bool**. <br/>
This type is relatively special because it his composed of only two values : **true** and **false**.

æ¬¡ã«ã€**Bool**ã¨ã„ã†æ–°ã—ã„å‹ã«ç§»ã‚Šã¾ã—ã‚‡ã†ã€‚<br/>
ã“ã®å‹ã¯æ¯”è¼ƒçš„ç‰¹æ®Šã§ã€2ã¤ã®å€¤ã®ã¿ã‹ã‚‰æ§‹æˆã•ã‚Œã‚‹ã€‚**true**ã¨false**ã®2ã¤ã®å€¤ã§æ§‹æˆã•ã‚Œã‚‹ã€‚

This type is often used with **if condition** to add conditions to your function.

ã“ã®å‹ã¯ã€ã—ã°ã—ã°**ifæ¡ä»¶**ã¨ä¸€ç·’ã«ä½¿ç”¨ã•ã‚Œã€é–¢æ•°ã«æ¡ä»¶ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

```
if(true) {
    // Do this
} else {
    // Do that
};

```

Now let me introduce the **equality** operator **==**. <br/>This operator is used to test if two values are equals. It returns a boolean indicating **true** or **false**.
We can actually combine the **==** operator with the **if condition**.

ã“ã“ã§ã€**å‡ç­‰**æ¼”ç®—å­*==*ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚<br/>ã“ã®æ¼”ç®—å­ã¯ã€2ã¤ã®å€¤ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€**true** ã¾ãŸã¯ **false** ã‚’ç¤ºã™ãƒ–ãƒ¼ãƒªã‚¢ãƒ³å€¤ã‚’è¿”ã—ã¾ã™ã€‚
å®Ÿéš›ã«ã¯ã€**==**æ¼”ç®—å­ã¨**ifæ¡ä»¶**ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```
if(1 == 1) {
    return ("Hello");
} else {
    return ("Ola");
};
```

â“ What do you think this expression will return ? ã“ã®å¼ã¯ä½•ã‚’è¿”ã™ã¨æ€ã„ã¾ã™ã‹ï¼Ÿ

It will return **Hello** indeed. <br/>
The condition 1 == 1 is always **true** so this expression is not extremly interesting. <br/> <br/> Let's move to something else and introduce variables into our condition.

ç¢ºã‹ã« **Hello** ãŒè¿”ã£ã¦ãã¾ã™ã€‚<br/>
1 == 1 ã¨ã„ã†æ¡ä»¶ã¯å¸¸ã« **true** ãªã®ã§ã€ã“ã®å¼ã¯ã‚ã¾ã‚Šé¢ç™½ãã‚ã‚Šã¾ã›ã‚“ã€‚<br/> <br/> ã§ã¯ã€ä»–ã®æ¡ä»¶ã«ç§»ã£ã¦ã€å¤‰æ•°ã‚’å°å…¥ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚


```
actor {
    public func equal_to_one (n : Nat) : async Text {
        if(n == 1) {
            return("n is equal to 1 !");
        } else {
            return ("n is not equal to 1 !");
        };
    };
};

```

We can actually test our function by deploying our actor and calling this function with different parameters.

å®Ÿéš›ã«ã‚¢ã‚¯ã‚¿ãƒ¼ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ã€ã“ã®é–¢æ•°ã‚’ç•°ãªã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§å‘¼ã³å‡ºã™ã“ã¨ã§ã€é–¢æ•°ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```
dfx canister call hello equal_to_one '(1)'
("n is equal to 1 !")
```

```
dfx canister call hello equal_to_one '(2)'
("n is not equal to 1 !")
```

Let me introduce other **relational operators** :
ãã®ä»–ã®**é–¢ä¿‚æ¼”ç®—å­**ã‚’ç´¹ä»‹ã—ã‚ˆã†ã€‚

- The **<** (less than) operator.
- **<** (less than) æ¼”ç®—å­.
  ```
  3 < 5     //true
  6 < 2     //false
  1 < 1     //false
  ```
- The **>** (more than) operator.
- **>** (more than) æ¼”ç®—å­.
  ```
  3 > 5     //false
  6 > 2     //true
  1 > 1     //false
  ```
- The **<=** (less than or equal to) operator.
- The **<=** (less than or equal to) æ¼”ç®—å­.
  ```
  3 <= 5    //true
  6 <= 2    //false
  1 <= 1    //true
  ```

- The **>=** (more than or equal to) operator.
- **>=** (more than or equal to) æ¼”ç®—å­.
  ```
  3 >= 5    //falser
  6 >= 2    //true
  1 >= 1    //true
  ```
- The **!=** (not equal) operator.
- **!=** (not equal) æ¼”ç®—å­.
  ```
  1 != 1    //false
  1 != 0    //true
  ```

We can use some of those new operators to rewrite our actor.

ãã‚Œã‚‰ã®æ–°ã—ã„æ¼”ç®—å­ã®ã„ãã¤ã‹ã‚’ä½¿ã£ã¦ã€ã‚¢ã‚¯ã‚¿ãƒ¼ã‚’æ›¸ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```
actor {
    public func inf_to_one (n : Nat) : async Text {
        if(n < 1){
            return("n is below 1 !");
        };
        if( n > 1){
            return("n is above 1 !");
        } else {
            return("n is equal to 1!");
        };
    };
};

```

You now have the mission to deploy this actor and test this function for different values. ğŸ˜‰

ã“ã®ã‚¢ã‚¯ã‚¿ãƒ¼ã‚’é…å‚™ã—ã€ç•°ãªã‚‹å€¤ã§ã“ã®æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ä½¿å‘½ãŒã‚ã‚Šã¾ã™ã€‚

# Challenge ğŸ®

Take a break and try completing challenge 5 and 6.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸5ã¨6ã®ã‚¯ãƒªã‚¢ã«æŒ‘æˆ¦ã—ã¦ãã ã•ã„ã€‚

# Array é…åˆ— ğŸ—ƒ

In Motoko, an **array** is a collection of **similar** data elements.

Motokoã§ã¯ã€**é…åˆ—**ã¯**é¡ä¼¼ã®**ãƒ‡ãƒ¼ã‚¿è¦ç´ ã®é›†ã¾ã‚Šã§ã™ã€‚

```
let array_1 : [Text] = ["Motoko", "is", "a", "great", "language", "."];

let array_2 : [Nat] = ["05", "07", "2021"];

let array_3 = ["This is not correct", 12345];   â›”ï¸ Not valid
```

As you can see array_3 is not valid; we are trying to mix a value of type Text with a value of type Nat. <br/> Again, an array can only contains elements of the similar type.

Text å‹ã®å€¤ã¨ Nat å‹ã®å€¤ã‚’æ··åœ¨ã•ã›ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã®ã§ã™ã€‚<br/>ç¹°ã‚Šè¿”ã—ã«ãªã‚Šã¾ã™ãŒã€é…åˆ—ã«ã¯åŒã˜å‹ã®è¦ç´ ã—ã‹å…¥ã‚Œã‚‰ã‚Œã¾ã›ã‚“ã€‚

ğŸ•µï¸â€â™‚ï¸ To access an element in an array we use an **index**. <br/> Array are indexed starting at zero. This means the first element in the array can be accessed using **array[0]**, the second element using **array[1]** and so on.
<br/> <br/> You can access the size of an array using **array.size()**.

ğŸ•µï¸â€â™‚ï¸  é…åˆ—ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã€**ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹**ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚<br/>é…åˆ—ã¯0ã‹ã‚‰å§‹ã¾ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æŒã¡ã¾ã™ã€‚ã¤ã¾ã‚Šã€é…åˆ—ã®æœ€åˆã®è¦ç´ ã«ã¯ **array[0]** ã‚’ã€2ç•ªç›®ã®è¦ç´ ã«ã¯ **array[1]** ã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã€ä»¥ä¸‹åŒæ§˜ã§ã™ã€‚
<br/> <br/>é…åˆ—ã®ã‚µã‚¤ã‚ºã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã€ **array.size()** ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

Let's rewrite our actor and play with what we've learned.

å­¦ã‚“ã ã“ã¨ã‚’æ´»ã‹ã—ã¦ã€å½¹è€…ã‚’æ›¸ãæ›ãˆã¦éŠã¼ã†ã€‚


```
actor {

    let array : [Text] = ["Motoko", "is", "a", "great", "language", "."];

    public func check_index(n : Nat) : async Text {
        return(array[n]);
    };

    public func check_size() : async Nat {
        returrn(array.size());
    };
};
```

ğŸ’¡ Note that the function check_size has no argument.
ğŸ’¡ é–¢æ•° check_size ã«ã¯å¼•æ•°ãŒãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

<br/>

â“ What do you think this command will return ?

â“ ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ä½•ã‚’è¿”ã™ã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ


```
dfx canister call hello check_size '()'
```

â“ What about this one ?

â“ ã“ã‚Œã¯ã©ã†ã§ã™ã‹ï¼Ÿ

```
dfx canister call hello check_index '(6)'
```

âœ… The first command will return **6** the second one should report a **trap** error indicating than the index is out of the bounds of the Array.

âœ… æœ€åˆã®ã‚³ãƒãƒ³ãƒ‰ã¯ **6** ã‚’è¿”ã—ã€2ç•ªç›®ã®ã‚³ãƒãƒ³ãƒ‰ã¯ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé…åˆ—ã®ç¯„å›²å¤–ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ **trap** ã‚¨ãƒ©ãƒ¼ã‚’å ±å‘Šã™ã‚‹ã¯ãšã§ã™ã€‚
ã‚’å ±å‘Šã™ã‚‹ã€‚

# Loop ãƒ«ãƒ¼ãƒ— â­

We can loop over an array using a **for** loop and the following syntax.
Copy and paste the following code and deploy the actor.

for**ãƒ«ãƒ¼ãƒ—ã¨æ¬¡ã®æ§‹æ–‡ã‚’ä½¿ã£ã¦ã€é…åˆ—ã®ä¸Šã‚’ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ã€ã‚¢ã‚¯ã‚¿ãƒ¼ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ãã ã•ã„ã€‚

```
import Debug "mo:base/Debug";

actor {
    let array : [Nat] = [1, 2, 3, 4, 5];

    public func test() : async () {
        for (value in array.vals()){
            Debug.print(debug_show(value))
        };
    };
};

```

This syntax means that we will go trough all values in the array and print them.
Once you've deployed the actor, run the following command.

ã“ã®æ§‹æ–‡ã¯ã€é…åˆ—å†…ã®ã™ã¹ã¦ã®å€¤ã‚’èª¿ã¹ã¦è¡¨ç¤ºã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
ã‚¢ã‚¯ã‚¿ãƒ¼ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸã‚‰ã€ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

```
dfx canister call hello test '()'
```

In your terminal (in the window that is running the replica) you should see this output.

ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ï¼ˆãƒ¬ãƒ—ãƒªã‚«ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ï¼‰ã§ã€æ¬¡ã®ã‚ˆã†ãªå‡ºåŠ›ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã¯ãšã§ã™ã€‚

<p align="center"> <img src="img/terminal.png" width="800"/> </p>

# Challenge ğŸ®

Take a break and try completing challenge 7 and 8.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸7ã€8ã®ã‚¯ãƒªã‚¢ã«æŒ‘æˆ¦ã—ã¦ãã ã•ã„ã€‚

# Module ğŸ§©

As you've probably noticed in the previous actor declaration, we have imported a **module** (called **Debug**). <br/>

å…ˆã»ã©ã®ã‚¢ã‚¯ã‚¿ãƒ¼å®£è¨€ã§ãŠæ°—ã¥ãã‹ã¨æ€ã„ã¾ã™ãŒã€**ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«**ï¼ˆ*Debug**ã¨ã„ã†åå‰ï¼‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚

A module is composed of code written by someone else that you can use in your own program. <br/>
We will see different ways to import modules and even how to create your own modules.
However, for today we only need to know how to import modules from the **base library**.

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã¯ã€ä»–ã®äººãŒæ›¸ã„ãŸã‚³ãƒ¼ãƒ‰ã‚’è‡ªåˆ†ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã‚‚ã®ã§ã™ã€‚<br/>
ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã•ã¾ã–ã¾ãªæ–¹æ³•ã¨ã€ç‹¬è‡ªã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦è¦‹ã¦ã„ãã¾ã™ã€‚
ã—ã‹ã—ã€ä»Šæ—¥ã®ã¨ã“ã‚ã¯ **ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ–ãƒ©ãƒª** ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹æ–¹æ³•ã ã‘çŸ¥ã£ã¦ã„ã‚Œã°ã‚ˆã„ã®ã§ã™ã€‚

ğŸ’¡ The **base library** is a set of modules to handle common operations on the most used types (Array, Bool, Nat, Int, Text...).

ğŸ’¡ **åŸºæœ¬ãƒ©ã‚¤ãƒ–ãƒ©ãƒª**ã¯ã€æœ€ã‚‚ã‚ˆãä½¿ã‚ã‚Œã‚‹å‹ï¼ˆArray, Bool, Nat, Int, Text...ï¼‰ã«å¯¾ã™ã‚‹å…±é€šã®æ“ä½œã‚’æ‰±ã†ãŸã‚ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç¾¤ã§ã™ã€‚


- The **source code** for this library is accessible <a href="https://github.com/dfinity/motoko-base" target="_blank"> here </a> and is maintained by engineers from the Dfinity foundation and community members.
- ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰**ã¯ã€<a href="https://github.com/dfinity/motoko-base" target="_blank">ã“ã¡ã‚‰</a> ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã€Dfinityè²¡å›£ã®ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¨ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ¡ãƒ³ãƒãƒ¼ã«ã‚ˆã£ã¦ç¶­æŒã•ã‚Œã¦ã„ã¾ã™ã€‚
  <br/>

- Each module has a **documentation** page where you can read about the available functions. Here is the documentation page for the <a href="https://smartcontracts.org/docs/base-libraries/Text.html" target="_blank"> Text </a> module.
- å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ** ãƒšãƒ¼ã‚¸ãŒã‚ã‚Šã€åˆ©ç”¨å¯èƒ½ãªé–¢æ•°ã«ã¤ã„ã¦èª­ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã“ã§ã¯ã€<a href="https://smartcontracts.org/docs/base-libraries/Text.html" target="_blank">Text</a> ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ»ãƒšãƒ¼ã‚¸ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚


The **source code** is meant to understand how a specific module was written whereas the **documentation** is meant to understand how you can use a module. <br/> You need to know how to use the **documentation** but you don't need to understand how the **source code** for these modules was written (expect if you are curious ğŸ‘€).

**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰** ã¯ç‰¹å®šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒã©ã®ã‚ˆã†ã«æ›¸ã‹ã‚ŒãŸã‹ã‚’ç†è§£ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã‚ã‚Šã€**ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³** ã¯ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã©ã®ã‚ˆã†ã«ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã‹ã‚’ç†è§£ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚<br/>ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**ã®ä½¿ã„æ–¹ã‚’çŸ¥ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã™ãŒã€ã“ã‚Œã‚‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®**ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰**ãŒã©ã®ã‚ˆã†ã«æ›¸ã‹ã‚ŒãŸã‹ã‚’ç†è§£ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆèˆˆå‘³ãŒã‚ã‚‹äººã¯åˆ¥ã§ã™ãŒğŸ‘€ï¼‰ã€‚

Here's an example that show how to import the <a href="https://smartcontracts.org/docs/base-libraries/Nat.html" target="_blank"> **Nat** </a> module and use the **toText** function.

ä»¥ä¸‹ã¯ã€<a href="https://smartcontracts.org/docs/base-libraries/Nat.html" target="_blank"> **Nat** </a>> ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã€**toText**é–¢æ•°ã‚’ä½¿ç”¨ã™ã‚‹ä¾‹ã§ã™ã€‚


```
import Nat "mo:base/Nat";

actor {
    public func nat_to_text(n : Nat) : async Text {
        return(Nat.toText(n));
    };
};
```

Here's the part of the documentation covering the function used.

ä»¥ä¸‹ã¯ã€ä½¿ç”¨ã—ãŸé–¢æ•°ã«é–¢ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®éƒ¨åˆ†ã§ã™ã€‚

<p align="center"> <img src="img/text.png" width="800"/> </p>

ğŸ’¡ At this point you might be wondering how we were using the type **Nat** in previous examples without importing the corresponding module. <br/> <br/>This is an important subtility to understand : the **_type_** Nat is by default available in Motoko but if you need to use one function from the **_module_** Nat you need to import the module before.

ğŸ’¡ ã“ã“ã§ï¼Œã“ã‚Œã¾ã§ã®ä¾‹ã§ï¼Œã©ã®ã‚ˆã†ã«ã—ã¦å¯¾å¿œã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã›ãšã« **Nat** ã¨ã„ã†å‹ã‚’ä½¿ç”¨ã—ã¦ã„ãŸã®ã‹ï¼Œä¸æ€è­°ã«æ€ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼<br/><br/>ã“ã‚Œã¯ç†è§£ã™ã¹ãé‡è¦ãªç‚¹ã§ã™ï¼š **_type_** Nat ã¯ Motoko ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§åˆ©ç”¨å¯èƒ½ã§ã™ãŒã€ **_module_** Nat ã®é–¢æ•°ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã€äº‹å‰ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```
actor {
    let a : Nat = 5; âœ… Valid.
    public func nat_to_text(n : Nat) : async Text {
        return(Nat.toText(n)); â›”ï¸ Incorrect without importing the module.
    };
};

```

# Challenge ğŸ®

Take a break and try completing challenge 9 and 10.

ä¸€æ¯ã¤ã„ã¦ã€ãƒãƒ£ãƒ¬ãƒ³ã‚¸9ã€10ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã¿ã¦ã¯ã„ã‹ãŒã§ã—ã‚‡ã†ã‹ã€‚
